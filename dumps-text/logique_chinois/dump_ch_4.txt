   #alternate 编辑本页 Wikipedia (zh) alternate alternate alternate alternate
   alternate alternate alternate alternate alternate alternate
   Wikipedia的Atom feed

   跳转到内容

   [ ] 主菜单
   主菜单
   (BUTTON) 移至侧栏 (BUTTON) 隐藏
   导航
     * 首页
     * 分类索引
     * 特色内容
     * 新闻动态
     * 最近更改
     * 随机条目

   帮助
     * 帮助
     * 维基社群
     * 方针与指引
     * 互助客栈
     * 知识问答
     * 字词转换
     * IRC即时聊天
     * 联络我们
     * 关于维基百科

   维基百科 自由的百科全书
   搜索
   ____________________
   (BUTTON) 搜索

   [ ] 外观

     * 资助维基百科
     * 创建账号
     * 登录

   [ ] 个人工具
     * 资助维基百科
     * 创建账号
     * 登录

   未登录编辑者的页面 了解详情
     * 贡献
     * 讨论

目录

   (BUTTON) 移至侧栏 (BUTTON) 隐藏
     * 序言
     * 1 术语
     * 2 例子
     * 3 把运算连接起来
       (BUTTON) 开关把运算连接起来子章节
          + 3.1 使用圆括号
     * 4 性质
     * 5 真值表
     * 6 其他记号
     * 7 布尔术语的基本数学使用
     * 8 布尔术语的英语使用
     * 9 应用
       (BUTTON) 开关应用子章节
          + 9.1 数字电子电路设计
          + 9.2 数据库应用
          + 9.3 搜索引擎查询
     * 10 参见
     * 11 外部链接

   [ ] 开关目录

布尔逻辑

   [ ] 1种语言
     * English

   编辑链接

     * 条目
     * 讨论

   [ ] 不转换
     * 不转换
     * 简体
     * 繁體
     * 大陆简体
     * 香港繁體
     * 澳門繁體
     * 大马简体
     * 新加坡简体
     * 臺灣正體

     * 阅读
     * 编辑
     * 查看历史

   [ ] 工具
   工具
   (BUTTON) 移至侧栏 (BUTTON) 隐藏
   操作
     * 阅读
     * 编辑
     * 查看历史

   常规
     * 链入页面
     * 相关更改
     * 上传文件
     * 特殊页面
     * 固定链接
     * 页面信息
     * 引用此页
     * 获取短链接
     * 下载二维码

   打印/导出
     * 下载为PDF
     * 打印页面

   在其他项目中
     * 维基数据项目

   外观
   (BUTTON) 移至侧栏 (BUTTON) 隐藏
   本页使用了标题或全文手工转换
   维基百科，自由的百科全书
   「布尔逻辑」的各地常用名稱
   中国大陸 布尔逻辑
    臺灣  布林運算

   布尔逻辑（英語：Boolean
   algebra）得名于乔治·布尔，他是爱尔兰科克的皇后学院的英国数学家，他在十九世纪中叶首次定义了逻辑的代数系统。现在，布尔逻辑在电子学、计算
   机硬件和软件中有很多应用。在1937年，克劳德·艾尔伍德·香农展示了布尔逻辑如何在电子学中使用。

   使用集合代数作为介绍布尔逻辑的一种方式。还使用文氏图来展示各种布尔逻辑陈述所描述的集合联系。

术语

   [编辑]
   [290px-Venn_A_intersect_B.svg.png] 文氏图，展示A AND B（紫罗兰色）的集合交集，A OR
   B（所有着色区域）的集合并集，和A XOR B的集合（除了紫罗兰色的所有着色区域）。方框表示"全集"。

   设X是一个集合：
     * 元素是一个集合的成员。表示为
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>∈</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \in
       }</annotation> </semantics> :MATH]
       {\displaystyle \in } 。如果它不是这个集合的元素，表示为
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>∉</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \notin
       }</annotation> </semantics> :MATH]
       {\displaystyle \notin } 。

     * 全集是集合X，有时表示为1。注意使用全集这个词意味着“虑及的所有元素”，不必然的同“现有的所有元素”一样。

     * 空集或null集合是没有元素的集合，表示为
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mi class="MJX-variant">∅</mi>
       </mstyle> </mrow> <annotation
       encoding="application/x-tex">{\displaystyle \varnothing
       }</annotation> </semantics> :MATH]
       {\displaystyle \varnothing } ，有时表示为0。

     * 一元算符应用于一个单一的集合。有一个一元算符叫做逻辑非（NOT）。它的作用是采用补集。

     * 二元算符应用于两个集合。基本的二元算符是逻辑或（OR）和逻辑与（AND）。它们进行集合的并集和交集。还有其他衍生的二元算符，比如逻辑异
       或（XOR，排他的或）。

     * 子集表示为A
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>⊆</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \subseteq
       }</annotation> </semantics> :MATH]
       {\displaystyle \subseteq } B，意味这在集合A中所有元素都在集合B中。

     * 真子集表示为A
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>⊂</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \subset
       }</annotation> </semantics> :MATH]
       {\displaystyle \subset } B，意味着在集合A中的所有元素都在集合B中，并且两个集合不等同。

     * 超集表示为A
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>⊇</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \supseteq
       }</annotation> </semantics> :MATH]
       {\displaystyle \supseteq } B，意味着在集合B中的所有元素都在集合A中。

     * 真超集表示为A
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>⊃</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \supset
       }</annotation> </semantics> :MATH]
       {\displaystyle \supset } B，意味着在集合B中的所有元素都在集合A中，并且两个集合不等同。

例子

   [编辑]
   [480px-Boolean_Multiples_of_2_3_5_cn.jpg]

   设图像为集合A包含"全集"中所有偶数（二的倍数），集合B包含"全集"中所有三的倍数。则两个集合的交集（在集合A AND
   B中所有的元素）将是"全集"中所有六的倍数。

   集合A的补集（所有不在集合A中的元素）是"全集"中所有的奇数。

把运算连接起来

   [编辑]

   尽管在任何布尔运算中都最多有两个集合参与，从这个运算所形成的新集合可以接着与其他集合联合起来实现另外的布尔运算。使用前面的例子，我们可以定义一
   个新集合C作为"全集"中所有五的倍数的集合。所以"集合A AND B AND
   C"将是"全集"中所有30的倍数。如果为了更方便，我们可以把集合AB当作集合A和B的交集，或者说"全集"中所有六的倍数的集合。那么我们可以称"
   集合AB AND C"是"全集"中所有30的倍数的集合。我们接着进一步的把这个结果叫做集合ABC。

使用圆括号

   [编辑]

   尽管任何数目的逻辑AND（或任何数目的逻辑OR）可以被连接在一起而没有歧义，AND和OR和NOT的组合可以导致歧义的情况。在这种情况下，可以使
   用圆括号来分清运算的次序。永远是最内的括号内的运算先进行，随后是外层的括号以此类推，直到在所有的括号内运算都完成。接着进行括号外的运算。

性质

   [编辑]

   为两个主要的二元运算的符号定义为
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mo>∧</mo> <mrow
   class="MJX-TeXAtom-ORD"> <mo>/</mo> </mrow> <mo>∩</mo> </mstyle>
   </mrow> <annotation encoding="application/x-tex">{\displaystyle \land
   /\cap }</annotation> </semantics> :MATH]
   {\displaystyle \land /\cap } (逻辑与/交集）和
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mo>∨</mo> <mrow
   class="MJX-TeXAtom-ORD"> <mo>/</mo> </mrow> <mo>∪</mo> </mstyle>
   </mrow> <annotation encoding="application/x-tex">{\displaystyle \lor
   /\cup }</annotation> </semantics> :MATH]
   {\displaystyle \lor /\cup } (逻辑或/并集），把单一的一元运算的符号定义为
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi mathvariant="normal">¬</mi>
   </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle \lnot }</annotation>
   </semantics> :MATH]
   {\displaystyle \lnot } /
   ~(逻辑非/补集）。我们还使用值0（逻辑假/空集）和1（逻辑真/全集）。下列性质适用于布尔代数和布尔逻辑二者：

   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mo
   stretchy="false">(</mo> <mi>b</mi> <mo>∨</mo> <mi>c</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mo stretchy="false">(</mo>
   <mi>a</mi> <mo>∨</mo> <mi>b</mi> <mo stretchy="false">)</mo> <mo>∨</mo>
   <mi>c</mi> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\lor (b\lor c)=(a\lor
   b)\lor c}</annotation> </semantics> :MATH]
   {\displaystyle a\lor (b\lor c)=(a\lor b)\lor c}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mo
   stretchy="false">(</mo> <mi>b</mi> <mo>∧</mo> <mi>c</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mo stretchy="false">(</mo>
   <mi>a</mi> <mo>∧</mo> <mi>b</mi> <mo stretchy="false">)</mo> <mo>∧</mo>
   <mi>c</mi> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\land (b\land c)=(a\land
   b)\land c}</annotation> </semantics> :MATH]
   {\displaystyle a\land (b\land c)=(a\land b)\land c} 结合律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mi>b</mi>
   <mo>=</mo> <mi>b</mi> <mo>∨</mo> <mi>a</mi> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle a\lor b=b\lor
   a}</annotation> </semantics> :MATH]
   {\displaystyle a\lor b=b\lor a}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mi>b</mi>
   <mo>=</mo> <mi>b</mi> <mo>∧</mo> <mi>a</mi> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle a\land b=b\land
   a}</annotation> </semantics> :MATH]
   {\displaystyle a\land b=b\land a} 交换律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mo
   stretchy="false">(</mo> <mi>a</mi> <mo>∧</mo> <mi>b</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mi>a</mi> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle a\lor (a\land
   b)=a}</annotation> </semantics> :MATH]
   {\displaystyle a\lor (a\land b)=a}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mo
   stretchy="false">(</mo> <mi>a</mi> <mo>∨</mo> <mi>b</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mi>a</mi> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle a\land (a\lor
   b)=a}</annotation> </semantics> :MATH]
   {\displaystyle a\land (a\lor b)=a} 吸收律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mo
   stretchy="false">(</mo> <mi>b</mi> <mo>∧</mo> <mi>c</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mo stretchy="false">(</mo>
   <mi>a</mi> <mo>∨</mo> <mi>b</mi> <mo stretchy="false">)</mo> <mo>∧</mo>
   <mo stretchy="false">(</mo> <mi>a</mi> <mo>∨</mo> <mi>c</mi> <mo
   stretchy="false">)</mo> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\lor (b\land c)=(a\lor
   b)\land (a\lor c)}</annotation> </semantics> :MATH]
   {\displaystyle a\lor (b\land c)=(a\lor b)\land (a\lor c)}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mo
   stretchy="false">(</mo> <mi>b</mi> <mo>∨</mo> <mi>c</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mo stretchy="false">(</mo>
   <mi>a</mi> <mo>∧</mo> <mi>b</mi> <mo stretchy="false">)</mo> <mo>∨</mo>
   <mo stretchy="false">(</mo> <mi>a</mi> <mo>∧</mo> <mi>c</mi> <mo
   stretchy="false">)</mo> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\land (b\lor c)=(a\land
   b)\lor (a\land c)}</annotation> </semantics> :MATH]
   {\displaystyle a\land (b\lor c)=(a\land b)\lor (a\land c)} 分配律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mi
   mathvariant="normal">¬</mi> <mi>a</mi> <mo>=</mo> <mn>1</mn> </mstyle>
   </mrow> <annotation encoding="application/x-tex">{\displaystyle a\lor
   \lnot a=1}</annotation> </semantics> :MATH]
   {\displaystyle a\lor \lnot a=1}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mi
   mathvariant="normal">¬</mi> <mi>a</mi> <mo>=</mo> <mn>0</mn> </mstyle>
   </mrow> <annotation encoding="application/x-tex">{\displaystyle a\land
   \lnot a=0}</annotation> </semantics> :MATH]
   {\displaystyle a\land \lnot a=0} 互补律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mi>a</mi>
   <mo>=</mo> <mi>a</mi> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\lor a=a}</annotation>
   </semantics> :MATH]
   {\displaystyle a\lor a=a}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mi>a</mi>
   <mo>=</mo> <mi>a</mi> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\land a=a}</annotation>
   </semantics> :MATH]
   {\displaystyle a\land a=a} 幂等律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mn>0</mn>
   <mo>=</mo> <mi>a</mi> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\lor 0=a}</annotation>
   </semantics> :MATH]
   {\displaystyle a\lor 0=a}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mn>1</mn>
   <mo>=</mo> <mi>a</mi> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\land 1=a}</annotation>
   </semantics> :MATH]
   {\displaystyle a\land 1=a} 有界律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∨</mo> <mn>1</mn>
   <mo>=</mo> <mn>1</mn> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\lor 1=1}</annotation>
   </semantics> :MATH]
   {\displaystyle a\lor 1=1}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi>a</mi> <mo>∧</mo> <mn>0</mn>
   <mo>=</mo> <mn>0</mn> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle a\land 0=0}</annotation>
   </semantics> :MATH]
   {\displaystyle a\land 0=0}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi mathvariant="normal">¬</mi>
   <mn>0</mn> <mo>=</mo> <mn>1</mn> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle \lnot 0=1}</annotation>
   </semantics> :MATH]
   {\displaystyle \lnot 0=1}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi mathvariant="normal">¬</mi>
   <mn>1</mn> <mo>=</mo> <mn>0</mn> </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle \lnot 1=0}</annotation>
   </semantics> :MATH]
   {\displaystyle \lnot 1=0} 0和1是互补的
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi mathvariant="normal">¬</mi>
   <mo stretchy="false">(</mo> <mi>a</mi> <mo>∨</mo> <mi>b</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mi mathvariant="normal">¬</mi>
   <mi>a</mi> <mo>∧</mo> <mi mathvariant="normal">¬</mi> <mi>b</mi>
   </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle \lnot (a\lor b)=\lnot
   a\land \lnot b}</annotation> </semantics> :MATH]
   {\displaystyle \lnot (a\lor b)=\lnot a\land \lnot b}
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi mathvariant="normal">¬</mi>
   <mo stretchy="false">(</mo> <mi>a</mi> <mo>∧</mo> <mi>b</mi> <mo
   stretchy="false">)</mo> <mo>=</mo> <mi mathvariant="normal">¬</mi>
   <mi>a</mi> <mo>∨</mo> <mi mathvariant="normal">¬</mi> <mi>b</mi>
   </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle \lnot (a\land b)=\lnot
   a\lor \lnot b}</annotation> </semantics> :MATH]
   {\displaystyle \lnot (a\land b)=\lnot a\lor \lnot b} 德·摩根定律
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">¬</mi> <mi>a</mi> <mo>=</mo> <mi>a</mi>
   </mstyle> </mrow> <annotation
   encoding="application/x-tex">{\displaystyle \lnot \lnot
   a=a}</annotation> </semantics> :MATH]
   {\displaystyle \lnot \lnot a=a} 对合律

真值表

   [编辑]

   布尔逻辑只使用两个值0和1，这两个值的交集和并集可以使用真值表定义如下：
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mo>∩</mo> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle \cap
   }</annotation> </semantics> :MATH]
   {\displaystyle \cap } 0 1
   0 0 0
   1 0 1
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mo>∪</mo> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle \cup
   }</annotation> </semantics> :MATH]
   {\displaystyle \cup } 0 1
   0 0 1
   1 1 1
     * 也可以建立涉及多个输入和其他布尔运算的更复杂的真值表。

     * 真值表应用在逻辑中，解释0为假，1为真，
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>∩</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \cap
       }</annotation> </semantics> :MATH]
       {\displaystyle \cap } 为与，
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>∪</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \cup
       }</annotation> </semantics> :MATH]
       {\displaystyle \cup } 为或，而¬为非。

其他记号

   [编辑]

   可以使用各种样式的基本算符来表达布尔逻辑。AND（与）、OR（或）、NOT（非）是最直觉的。数学家、工程师和程序员经常使用 +表示或，
   [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
   displaystyle="true" scriptlevel="0"> <mo>⋅</mo> </mstyle> </mrow>
   <annotation encoding="application/x-tex">{\displaystyle \cdot
   }</annotation> </semantics> :MATH]
   {\displaystyle \cdot }
   表示与（因为在某些方面这些运算类似于在其他代数结构中的加法和乘法，并且这种记号使熟悉普通代数的人易于得到积之和范式）。非也表示为在要否定的表达
   式顶上的一个横线。

   另一种记号使用"交"表示与使用"并"表示或。但是这会导致混淆，因为术语"并"也经常用于合并集合的另一个布尔运算，它包括了与和或二者。

布尔术语的基本数学使用

   [编辑]
     * 在联立方程的情况下，被联立的方程暗含逻辑与：

                x + y = 2

                AND

                x - y = 2

   同样适用于联立不等式：

                x + y < 2

                AND

                x - y < 2

     * 大于等于号（
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>≥</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \geq
       }</annotation> </semantics> :MATH]
       {\displaystyle \geq } ）和小于等于号（
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>≤</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \leq
       }</annotation> </semantics> :MATH]
       {\displaystyle \leq } ），可以认为是暗含逻辑或的一对等式与不等式的联立：

                X < 2

                OR

                X = 2

     * 加/减号（
       [MATH: <semantics> <mrow class="MJX-TeXAtom-ORD"> <mstyle
       displaystyle="true" scriptlevel="0"> <mo>±</mo> </mstyle> </mrow>
       <annotation encoding="application/x-tex">{\displaystyle \pm
       }</annotation> </semantics> :MATH]
       {\displaystyle \pm } ），在表示“平方根的解”情况下，可以被看作暗含逻辑或的一对联立等式：

                WIDTH = 3

                OR

                WIDTH = -3

布尔术语的英语使用

   [编辑]

   在把英语句子转换成形式的布尔语句的时候要小心。很多英语词语不精确的意义可能导致多种逻辑结果，例如英语单词NOT（非）：“所有闪光的东西不是金子
   。”可以解析为以下不同的逻辑表达：
     * “没有闪光的东西是金子”
     * “有些闪光的东西不是金子”

   作为英语单词的AND（与）和OR（或）在特定情况下是可以互换使用的：
     * "在下雨与下雪的时候我总是带伞。"
     * "在下雨或下雪的时候我总是带伞。"

   还要注意在英语中单词OR（或）可以分别对应于逻辑表达中的或（OR）（此亦彼亦）和异或（XOR）（此即彼非），具体意思要依赖于上下文进行判断：
     * "我在潮湿或高温的时候出汗。"（此亦彼亦，判定为逻辑或）
     * "我午饭打算吃鸡肉或牛肉。"（此即彼非，判定为逻辑异或）

   在规定计算机程序或者电子电路时，如何使用英语准确描述其功能逻辑是个关键问题。例如，对于功能“程序应校验申请者已经选择取了男性或女性单选框”，应
   当被当作一个异或（非此即彼）逻辑（即“程序应校验申请者已经选择取了男性或女性选项，并且此二选项互相排他”），则程序语句须特别限定“二者之间只有
   一个能被选择”来确保校验功能的实现；假如将其混为或逻辑（此亦彼亦），则该校验功能有可能被错误地实现，造成申请者同时选择两个选项、而校验依然通过
   。

   在其他非技术语言的情况下，对于一段英语文字的解释可能包含更多的不确定性，可能需要深入探讨、以确保明晰该段文字背后所含的逻辑意义的多种可能性。

应用

   [编辑]

数字电子电路设计

   [编辑]

   布尔逻辑还在电子工程中的电路设计中使用；这里的0和1表示在数字电路中某一个位的不同状态，典型的是高和低电压。使用包含变量的表达式描述电路，并且
   对于这些变量的所有的值两个这种表达式是等价的，当且仅当对应的电路有相同的输入-输出行为。进一步的说，每种可能的输入-输出行为都被建模为适合的布
   尔表达式。

   基本的逻辑閘比如與閘、或閘、非閘可以单独使用，或者联合成與非閘、或非閘和異或閘来控制数字电子和电路。这些閘的串联或并联控制了运算的优先级。

数据库应用

   [编辑]

   关系数据库使用SQL语言，或者其他特定于数据库的语言，来进行查询，它可以包含布尔逻辑。对于这种应用，在表中每个记录都可以被当作"集合"的"元素
   "。例如，在SQL中，下列SELECT语句被用来从在数据库中的表格中检索数据：
     * SELECT * FROM EMPLOYEES WHERE LAST_NAME = 'Smith' AND FIRST_NAME =
       'John' ;

     * SELECT * FROM EMPLOYEES WHERE LAST_NAME = 'Smith' OR FIRST_NAME =
       'John' ;

     * SELECT * FROM EMPLOYEES WHERE NOT LAST_NAME = 'Smith' ;

   在有多个运算出现的时候，可以使用圆括号来明确的指定布尔运算发生的次序：
     * SELECT * FROM EMPLOYEES WHERE（NOT LAST_NAME =
       'Smith'）AND（FIRST_NAME = 'John' OR FIRST_NAME = 'Mary'）;

   在需要的时候可以使用嵌套的圆括号。

   联合两个（或更多）表格的任何布尔运算在关系数据库术语中都被称为连接。

搜索引擎查询

   [编辑]

   对于这种应用，在互联网上的每个web页面都被当作是"集合"的"元素"。各种在线搜索引擎使用各自不同的语法。下面描述Google使用的语法。
     * 逻辑与不使用符号。所以，它是连接两个搜索项的缺省方式：

                "搜索项1" "搜索项2"

     * 使用关键字OR表示逻辑或：

                "搜索项1" OR "搜索项2"

     * 使用减号表示逻辑非：

                -"搜索项1"

     * 不支持使用圆括号来明确指定运算的次序。

参见

   [编辑]
     * 布尔代数主题列表
     * 布尔代数
     * 布尔函数
     * 命题逻辑
     * 逻辑门
     * 文氏图
     * 并集
     * 补集
     * 交集

外部链接

   [编辑]
     * 逻辑的演算 （页面存档备份，存于互联网档案馆）, George Boole著, Cambridge and Dublin
       Mathematical Journal Vol. III (1848), pp. 183-98.
     * Logical Formula Evaluator （页面存档备份，存于互联网档案馆）（for Windows）, a
       software which calculates all possible values of a logical formula
     * How Stuff Works - Boolean Logic （页面存档备份，存于互联网档案馆）
     * Maiki & Boaz BDD-PROJECT, a Web Application for BDD reduction and
       visualization.

     * 查
     * 论
     * 编

   数字系统
   组件
   逻辑门 · 数字电路 · 集成电路 (IC)
   理论
   布尔逻辑 · 數位訊號處理 · 计算机系统结构
   应用
   數位音訊 · 數位摄影 · 数字视频

   检索自“https://zh.wikipedia.org/w/index.php?title=布尔逻辑&oldid=76912914”

   分类：​
     * 邏輯
     * 代数逻辑
     * 布尔代数
     * 形式逻辑系统

   隐藏分类：​
     * 含有英語的條目

     * 本页面最后修订于2023年4月21日 (星期五) 13:37。
     * 本站的全部文字在知识共享 署名-相同方式共享 4.0协议之条款下提供，附加条款亦可能应用。（请参阅使用条款）
       Wikipedia®和维基百科标志是维基媒体基金会的注册商标；维基™是维基媒体基金会的商标。
       维基媒体基金会是按美国国內稅收法501(c)(3)登记的非营利慈善机构。

     * 隐私政策
     * 关于维基百科
     * 免责声明
     * 行为准则
     * 开发者
     * 统计
     * Cookie声明
     * 手机版视图

     * Wikimedia Foundation
     * Powered by MediaWiki
