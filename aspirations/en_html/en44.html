<!DOCTYPE html>
<html class="client-nojs vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-1 vector-feature-appearance-pinned-clientpref-1 vector-feature-night-mode-enabled skin-theme-clientpref-day vector-toc-available" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Logic programming - Wikipedia</title>
<script>(function(){var className="client-js vector-feature-language-in-header-enabled vector-feature-language-in-main-page-header-disabled vector-feature-sticky-header-disabled vector-feature-page-tools-pinned-disabled vector-feature-toc-pinned-clientpref-1 vector-feature-main-menu-pinned-disabled vector-feature-limited-width-clientpref-1 vector-feature-limited-width-content-enabled vector-feature-custom-font-size-clientpref-1 vector-feature-appearance-pinned-clientpref-1 vector-feature-night-mode-enabled skin-theme-clientpref-day vector-toc-available";var cookie=document.cookie.match(/(?:^|; )enwikimwclientpreferences=([^;]+)/);if(cookie){cookie[1].split('%2C').forEach(function(pref){className=className.replace(new RegExp('(^| )'+pref.replace(/-clientpref-\w+$|[^\w-]+/g,'')+'-clientpref-\\w+( |$)'),'$1'+pref+'$2');});}document.documentElement.className=className;}());RLCONF={"wgBreakFrames":false,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy",
"wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"467f7a56-51ac-4bd3-a396-6aad9911c0e7","wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Logic_programming","wgTitle":"Logic programming","wgCurRevisionId":1259279203,"wgRevisionId":1259279203,"wgArticleId":17927,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["CS1 maint: DOI inactive as of November 2024","Articles with short description","Short description matches Wikidata","CS1: long volume value","Commons category link from Wikidata","Webarchive template wayback links","Logic programming","Computer-related introductions in 1972","Programming paradigms","Logic"],"wgPageViewLanguage":"en","wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Logic_programming","wgRelevantArticleId":17927,
"wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgNoticeProject":"wikipedia","wgCiteReferencePreviewsActive":false,"wgFlaggedRevsParams":{"tags":{"status":{"levels":1}}},"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsFlags":0,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgMFDisplayWikibaseDescriptions":{"search":true,"watchlist":true,"tagline":false,"nearby":true},"wgWMESchemaEditAttemptStepOversample":false,"wgWMEPageLength":90000,"wgRelatedArticlesCompat":[],"wgEditSubmitButtonLabelPublish":true,"wgULSPosition":"interlanguage","wgULSisCompactLinksEnabled":false,"wgVector2022LanguageInHeader":true,"wgULSisLanguageSelectorEmpty":false,"wgWikibaseItemId":"Q275603","wgCheckUserClientHintsHeadersJsApi":["brands","architecture","bitness","fullVersionList","mobile","model","platform","platformVersion"],"GEHomepageSuggestedEditsEnableTopics":true,
"wgGETopicsMatchModeEnabled":false,"wgGEStructuredTaskRejectionReasonTextInputEnabled":false,"wgGELevelingUpEnabledForUser":false};RLSTATE={"ext.globalCssJs.user.styles":"ready","site.styles":"ready","user.styles":"ready","ext.globalCssJs.user":"ready","user":"ready","user.options":"loading","ext.pygments":"ready","ext.cite.styles":"ready","skins.vector.search.codex.styles":"ready","skins.vector.styles":"ready","skins.vector.icons":"ready","jquery.makeCollapsible.styles":"ready","ext.wikimediamessages.styles":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","wikibase.client.init":"ready","ext.wikimediaBadges":"ready"};RLPAGEMODULES=["ext.pygments.view","ext.cite.ux-enhancements","site","mediawiki.page.ready","jquery.makeCollapsible","mediawiki.toc","skins.vector.js","ext.centralNotice.geoIP","ext.centralNotice.startUp","ext.gadget.ReferenceTooltips","ext.gadget.switcher","ext.urlShortener.toolbar","ext.centralauth.centralautologin",
"mmv.bootstrap","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.echo.centralauth","ext.eventLogging","ext.wikimediaEvents","ext.navigationTiming","ext.uls.interface","ext.cx.eventlogging.campaigns","ext.cx.uls.quick.actions","wikibase.client.vector-2022","ext.checkUser.clientHints","ext.growthExperiments.SuggestedEditSession"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.impl(function(){return["user.options@12s5i",function($,jQuery,require,module){mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
}];});});</script>
<link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=ext.cite.styles%7Cext.pygments%2CwikimediaBadges%7Cext.uls.interlanguage%7Cext.visualEditor.desktopArticleTarget.noscript%7Cext.wikimediamessages.styles%7Cjquery.makeCollapsible.styles%7Cskins.vector.icons%2Cstyles%7Cskins.vector.search.codex.styles%7Cwikibase.client.init&amp;only=styles&amp;skin=vector-2022">
<script async="" src="/w/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector-2022"></script>
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector-2022">
<meta name="generator" content="MediaWiki 1.44.0-wmf.8">
<meta name="referrer" content="origin">
<meta name="referrer" content="origin-when-cross-origin">
<meta name="robots" content="max-image-preview:standard">
<meta name="format-detection" content="telephone=no">
<meta name="viewport" content="width=1120">
<meta property="og:title" content="Logic programming - Wikipedia">
<meta property="og:type" content="website">
<link rel="preconnect" href="//upload.wikimedia.org">
<link rel="alternate" media="only screen and (max-width: 640px)" href="//en.m.wikipedia.org/wiki/Logic_programming">
<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Logic_programming&amp;action=edit">
<link rel="apple-touch-icon" href="/static/apple-touch/wikipedia.png">
<link rel="icon" href="/static/favicon/wikipedia.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/w/rest.php/v1/search" title="Wikipedia (en)">
<link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd">
<link rel="canonical" href="https://en.wikipedia.org/wiki/Logic_programming">
<link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">
<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom">
<link rel="dns-prefetch" href="//meta.wikimedia.org" />
<link rel="dns-prefetch" href="login.wikimedia.org">
</head>
<body class="skin--responsive skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-Logic_programming rootpage-Logic_programming skin-vector-2022 action-view"><a class="mw-jump-link" href="#bodyContent">Jump to content</a>
<div class="vector-header-container">
	<header class="vector-header mw-header">
		<div class="vector-header-start">
			<nav class="vector-main-menu-landmark" aria-label="Site">
				
<div id="vector-main-menu-dropdown" class="vector-dropdown vector-main-menu-dropdown vector-button-flush-left vector-button-flush-right"  >
	<input type="checkbox" id="vector-main-menu-dropdown-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-main-menu-dropdown" class="vector-dropdown-checkbox "  aria-label="Main menu"  >
	<label id="vector-main-menu-dropdown-label" for="vector-main-menu-dropdown-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"  ><span class="vector-icon mw-ui-icon-menu mw-ui-icon-wikimedia-menu"></span>

<span class="vector-dropdown-label-text">Main menu</span>
	</label>
	<div class="vector-dropdown-content">


				<div id="vector-main-menu-unpinned-container" class="vector-unpinned-container">
		
<div id="vector-main-menu" class="vector-main-menu vector-pinnable-element">
	<div
	class="vector-pinnable-header vector-main-menu-pinnable-header vector-pinnable-header-unpinned"
	data-feature-name="main-menu-pinned"
	data-pinnable-element-id="vector-main-menu"
	data-pinned-container-id="vector-main-menu-pinned-container"
	data-unpinned-container-id="vector-main-menu-unpinned-container"
>
	<div class="vector-pinnable-header-label">Main menu</div>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-main-menu.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-main-menu.unpin">hide</button>
</div>

	
<div id="p-navigation" class="vector-menu mw-portlet mw-portlet-navigation"  >
	<div class="vector-menu-heading">
		Navigation
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="n-mainpage-description" class="mw-list-item"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"><span>Main page</span></a></li><li id="n-contents" class="mw-list-item"><a href="/wiki/Wikipedia:Contents" title="Guides to browsing Wikipedia"><span>Contents</span></a></li><li id="n-currentevents" class="mw-list-item"><a href="/wiki/Portal:Current_events" title="Articles related to current events"><span>Current events</span></a></li><li id="n-randompage" class="mw-list-item"><a href="/wiki/Special:Random" title="Visit a randomly selected article [x]" accesskey="x"><span>Random article</span></a></li><li id="n-aboutsite" class="mw-list-item"><a href="/wiki/Wikipedia:About" title="Learn about Wikipedia and how it works"><span>About Wikipedia</span></a></li><li id="n-contactpage" class="mw-list-item"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia"><span>Contact us</span></a></li>
		</ul>
		
	</div>
</div>

	
	
<div id="p-interaction" class="vector-menu mw-portlet mw-portlet-interaction"  >
	<div class="vector-menu-heading">
		Contribute
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="n-help" class="mw-list-item"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia"><span>Help</span></a></li><li id="n-introduction" class="mw-list-item"><a href="/wiki/Help:Introduction" title="Learn how to edit Wikipedia"><span>Learn to edit</span></a></li><li id="n-portal" class="mw-list-item"><a href="/wiki/Wikipedia:Community_portal" title="The hub for editors"><span>Community portal</span></a></li><li id="n-recentchanges" class="mw-list-item"><a href="/wiki/Special:RecentChanges" title="A list of recent changes to Wikipedia [r]" accesskey="r"><span>Recent changes</span></a></li><li id="n-upload" class="mw-list-item"><a href="/wiki/Wikipedia:File_upload_wizard" title="Add images or other media for use on Wikipedia"><span>Upload file</span></a></li>
		</ul>
		
	</div>
</div>

</div>

				</div>

	</div>
</div>

		</nav>
			
<a href="/wiki/Main_Page" class="mw-logo">
	<img class="mw-logo-icon" src="/static/images/icons/wikipedia.png" alt="" aria-hidden="true" height="50" width="50">
	<span class="mw-logo-container skin-invert">
		<img class="mw-logo-wordmark" alt="Wikipedia" src="/static/images/mobile/copyright/wikipedia-wordmark-en.svg" style="width: 7.5em; height: 1.125em;">
		<img class="mw-logo-tagline" alt="The Free Encyclopedia" src="/static/images/mobile/copyright/wikipedia-tagline-en.svg" width="117" height="13" style="width: 7.3125em; height: 0.8125em;">
	</span>
</a>

		</div>
		<div class="vector-header-end">
			
<div id="p-search" role="search" class="vector-search-box-vue  vector-search-box-collapses vector-search-box-show-thumbnail vector-search-box-auto-expand-width vector-search-box">
	<a href="/wiki/Special:Search" class="cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only search-toggle" title="Search Wikipedia [f]" accesskey="f"><span class="vector-icon mw-ui-icon-search mw-ui-icon-wikimedia-search"></span>

<span>Search</span>
	</a>
	<div class="vector-typeahead-search-container">
		<div class="cdx-typeahead-search cdx-typeahead-search--show-thumbnail cdx-typeahead-search--auto-expand-width">
			<form action="/w/index.php" id="searchform" class="cdx-search-input cdx-search-input--has-end-button">
				<div id="simpleSearch" class="cdx-search-input__input-wrapper"  data-search-loc="header-moved">
					<div class="cdx-text-input cdx-text-input--has-start-icon">
						<input
							class="cdx-text-input__input"
							 type="search" name="search" placeholder="Search Wikipedia" aria-label="Search Wikipedia" autocapitalize="sentences" title="Search Wikipedia [f]" accesskey="f" id="searchInput"
							>
						<span class="cdx-text-input__icon cdx-text-input__start-icon"></span>
					</div>
					<input type="hidden" name="title" value="Special:Search">
				</div>
				<button class="cdx-button cdx-search-input__end-button">Search</button>
			</form>
		</div>
	</div>
</div>

			<nav class="vector-user-links vector-user-links-wide" aria-label="Personal tools">
	<div class="vector-user-links-main">
	
<div id="p-vector-user-menu-preferences" class="vector-menu mw-portlet emptyPortlet"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			
		</ul>
		
	</div>
</div>

	
<div id="p-vector-user-menu-userpage" class="vector-menu mw-portlet emptyPortlet"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			
		</ul>
		
	</div>
</div>

	<nav class="vector-appearance-landmark" aria-label="Appearance">
		
<div id="vector-appearance-dropdown" class="vector-dropdown "  title="Change the appearance of the page&#039;s font size, width, and color" >
	<input type="checkbox" id="vector-appearance-dropdown-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-appearance-dropdown" class="vector-dropdown-checkbox "  aria-label="Appearance"  >
	<label id="vector-appearance-dropdown-label" for="vector-appearance-dropdown-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"  ><span class="vector-icon mw-ui-icon-appearance mw-ui-icon-wikimedia-appearance"></span>

<span class="vector-dropdown-label-text">Appearance</span>
	</label>
	<div class="vector-dropdown-content">


			<div id="vector-appearance-unpinned-container" class="vector-unpinned-container">
				
			</div>
		
	</div>
</div>

	</nav>
	
<div id="p-vector-user-menu-notifications" class="vector-menu mw-portlet emptyPortlet"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			
		</ul>
		
	</div>
</div>

	
<div id="p-vector-user-menu-overflow" class="vector-menu mw-portlet"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			<li id="pt-sitesupport-2" class="user-links-collapsible-item mw-list-item user-links-collapsible-item"><a data-mw="interface" href="https://donate.wikimedia.org/?wmf_source=donate&amp;wmf_medium=sidebar&amp;wmf_campaign=en.wikipedia.org&amp;uselang=en" class=""><span>Donate</span></a>
</li>
<li id="pt-createaccount-2" class="user-links-collapsible-item mw-list-item user-links-collapsible-item"><a data-mw="interface" href="/w/index.php?title=Special:CreateAccount&amp;returnto=Logic+programming" title="You are encouraged to create an account and log in; however, it is not mandatory" class=""><span>Create account</span></a>
</li>
<li id="pt-login-2" class="user-links-collapsible-item mw-list-item user-links-collapsible-item"><a data-mw="interface" href="/w/index.php?title=Special:UserLogin&amp;returnto=Logic+programming" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o" class=""><span>Log in</span></a>
</li>

			
		</ul>
		
	</div>
</div>

	</div>
	
<div id="vector-user-links-dropdown" class="vector-dropdown vector-user-menu vector-button-flush-right vector-user-menu-logged-out"  title="Log in and more options" >
	<input type="checkbox" id="vector-user-links-dropdown-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-user-links-dropdown" class="vector-dropdown-checkbox "  aria-label="Personal tools"  >
	<label id="vector-user-links-dropdown-label" for="vector-user-links-dropdown-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"  ><span class="vector-icon mw-ui-icon-ellipsis mw-ui-icon-wikimedia-ellipsis"></span>

<span class="vector-dropdown-label-text">Personal tools</span>
	</label>
	<div class="vector-dropdown-content">


		
<div id="p-personal" class="vector-menu mw-portlet mw-portlet-personal user-links-collapsible-item"  title="User menu" >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="pt-sitesupport" class="user-links-collapsible-item mw-list-item"><a href="https://donate.wikimedia.org/?wmf_source=donate&amp;wmf_medium=sidebar&amp;wmf_campaign=en.wikipedia.org&amp;uselang=en"><span>Donate</span></a></li><li id="pt-createaccount" class="user-links-collapsible-item mw-list-item"><a href="/w/index.php?title=Special:CreateAccount&amp;returnto=Logic+programming" title="You are encouraged to create an account and log in; however, it is not mandatory"><span class="vector-icon mw-ui-icon-userAdd mw-ui-icon-wikimedia-userAdd"></span> <span>Create account</span></a></li><li id="pt-login" class="user-links-collapsible-item mw-list-item"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Logic+programming" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o"><span class="vector-icon mw-ui-icon-logIn mw-ui-icon-wikimedia-logIn"></span> <span>Log in</span></a></li>
		</ul>
		
	</div>
</div>

<div id="p-user-menu-anon-editor" class="vector-menu mw-portlet mw-portlet-user-menu-anon-editor"  >
	<div class="vector-menu-heading">
		Pages for logged out editors <a href="/wiki/Help:Introduction" aria-label="Learn more about editing"><span>learn more</span></a>
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="pt-anoncontribs" class="mw-list-item"><a href="/wiki/Special:MyContributions" title="A list of edits made from this IP address [y]" accesskey="y"><span>Contributions</span></a></li><li id="pt-anontalk" class="mw-list-item"><a href="/wiki/Special:MyTalk" title="Discussion about edits from this IP address [n]" accesskey="n"><span>Talk</span></a></li>
		</ul>
		
	</div>
</div>

	
	</div>
</div>

</nav>

		</div>
	</header>
</div>
<div class="mw-page-container">
	<div class="mw-page-container-inner">
		<div class="vector-sitenotice-container">
			<div id="siteNotice"><!-- CentralNotice --></div>
		</div>
		<div class="vector-column-start">
			<div class="vector-main-menu-container">
		<div id="mw-navigation">
			<nav id="mw-panel" class="vector-main-menu-landmark" aria-label="Site">
				<div id="vector-main-menu-pinned-container" class="vector-pinned-container">
				
				</div>
		</nav>
		</div>
	</div>
	<div class="vector-sticky-pinned-container">
				<nav id="mw-panel-toc" aria-label="Contents" data-event-name="ui.sidebar-toc" class="mw-table-of-contents-container vector-toc-landmark">
					<div id="vector-toc-pinned-container" class="vector-pinned-container">
					<div id="vector-toc" class="vector-toc vector-pinnable-element">
	<div
	class="vector-pinnable-header vector-toc-pinnable-header vector-pinnable-header-pinned"
	data-feature-name="toc-pinned"
	data-pinnable-element-id="vector-toc"
	
	
>
	<h2 class="vector-pinnable-header-label">Contents</h2>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-toc.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-toc.unpin">hide</button>
</div>


	<ul class="vector-toc-contents" id="mw-panel-toc-list">
		<li id="toc-mw-content-text"
			class="vector-toc-list-item vector-toc-level-1">
			<a href="#" class="vector-toc-link">
				<div class="vector-toc-text">(Top)</div>
			</a>
		</li>
		<li id="toc-History"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#History">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">1</span>
				<span>History</span>
			</div>
		</a>
		
		<ul id="toc-History-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Concepts"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Concepts">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">2</span>
				<span>Concepts</span>
			</div>
		</a>
		
			<button aria-controls="toc-Concepts-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Concepts subsection</span>
			</button>
		
		<ul id="toc-Concepts-sublist" class="vector-toc-list">
			<li id="toc-Algorithm_=_Logic_+_Control"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Algorithm_=_Logic_+_Control">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.1</span>
					<span>Algorithm = Logic + Control</span>
				</div>
			</a>
			
			<ul id="toc-Algorithm_=_Logic_+_Control-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Relationship_with_functional_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Relationship_with_functional_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.2</span>
					<span>Relationship with functional programming</span>
				</div>
			</a>
			
			<ul id="toc-Relationship_with_functional_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Relationship_with_relational_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Relationship_with_relational_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.3</span>
					<span>Relationship with relational programming</span>
				</div>
			</a>
			
			<ul id="toc-Relationship_with_relational_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Semantics_of_Horn_clause_programs"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Semantics_of_Horn_clause_programs">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.4</span>
					<span>Semantics of Horn clause programs</span>
				</div>
			</a>
			
			<ul id="toc-Semantics_of_Horn_clause_programs-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Negation_as_failure"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Negation_as_failure">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.5</span>
					<span>Negation as failure</span>
				</div>
			</a>
			
			<ul id="toc-Negation_as_failure-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Metalogic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Metalogic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.6</span>
					<span>Metalogic programming</span>
				</div>
			</a>
			
			<ul id="toc-Metalogic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Relationship_with_the_Computational-representational_understanding_of_mind"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Relationship_with_the_Computational-representational_understanding_of_mind">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.7</span>
					<span>Relationship with the Computational-representational understanding of mind</span>
				</div>
			</a>
			
			<ul id="toc-Relationship_with_the_Computational-representational_understanding_of_mind-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Knowledge_representation"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Knowledge_representation">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">2.8</span>
					<span>Knowledge representation</span>
				</div>
			</a>
			
			<ul id="toc-Knowledge_representation-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Variants_and_extensions"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Variants_and_extensions">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">3</span>
				<span>Variants and extensions</span>
			</div>
		</a>
		
			<button aria-controls="toc-Variants_and_extensions-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Variants and extensions subsection</span>
			</button>
		
		<ul id="toc-Variants_and_extensions-sublist" class="vector-toc-list">
			<li id="toc-Prolog"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Prolog">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.1</span>
					<span>Prolog</span>
				</div>
			</a>
			
			<ul id="toc-Prolog-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Constraint_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Constraint_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.2</span>
					<span>Constraint logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Constraint_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Datalog"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Datalog">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.3</span>
					<span>Datalog</span>
				</div>
			</a>
			
			<ul id="toc-Datalog-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Answer_set_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Answer_set_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.4</span>
					<span>Answer set programming</span>
				</div>
			</a>
			
			<ul id="toc-Answer_set_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Abductive_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Abductive_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.5</span>
					<span>Abductive logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Abductive_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Inductive_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Inductive_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.6</span>
					<span>Inductive logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Inductive_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Concurrent_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Concurrent_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.7</span>
					<span>Concurrent logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Concurrent_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Concurrent_constraint_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Concurrent_constraint_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.8</span>
					<span>Concurrent constraint logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Concurrent_constraint_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Higher-order_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Higher-order_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.9</span>
					<span>Higher-order logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Higher-order_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Linear_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Linear_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.10</span>
					<span>Linear logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Linear_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Object-oriented_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Object-oriented_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.11</span>
					<span>Object-oriented logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Object-oriented_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Transaction_logic_programming"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Transaction_logic_programming">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">3.12</span>
					<span>Transaction logic programming</span>
				</div>
			</a>
			
			<ul id="toc-Transaction_logic_programming-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-See_also"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#See_also">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">4</span>
				<span>See also</span>
			</div>
		</a>
		
		<ul id="toc-See_also-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Citations"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Citations">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">5</span>
				<span>Citations</span>
			</div>
		</a>
		
		<ul id="toc-Citations-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-Sources"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Sources">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">6</span>
				<span>Sources</span>
			</div>
		</a>
		
			<button aria-controls="toc-Sources-sublist" class="cdx-button cdx-button--weight-quiet cdx-button--icon-only vector-toc-toggle">
				<span class="vector-icon mw-ui-icon-wikimedia-expand"></span>
				<span>Toggle Sources subsection</span>
			</button>
		
		<ul id="toc-Sources-sublist" class="vector-toc-list">
			<li id="toc-General_introductions"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#General_introductions">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.1</span>
					<span>General introductions</span>
				</div>
			</a>
			
			<ul id="toc-General_introductions-sublist" class="vector-toc-list">
			</ul>
		</li>
		<li id="toc-Other_sources"
			class="vector-toc-list-item vector-toc-level-2">
			<a class="vector-toc-link" href="#Other_sources">
				<div class="vector-toc-text">
					<span class="vector-toc-numb">6.2</span>
					<span>Other sources</span>
				</div>
			</a>
			
			<ul id="toc-Other_sources-sublist" class="vector-toc-list">
			</ul>
		</li>
	</ul>
	</li>
	<li id="toc-Further_reading"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#Further_reading">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">7</span>
				<span>Further reading</span>
			</div>
		</a>
		
		<ul id="toc-Further_reading-sublist" class="vector-toc-list">
		</ul>
	</li>
	<li id="toc-External_links"
		class="vector-toc-list-item vector-toc-level-1">
		<a class="vector-toc-link" href="#External_links">
			<div class="vector-toc-text">
				<span class="vector-toc-numb">8</span>
				<span>External links</span>
			</div>
		</a>
		
		<ul id="toc-External_links-sublist" class="vector-toc-list">
		</ul>
	</li>
</ul>
</div>

					</div>
		</nav>
			</div>
		</div>
		<div class="mw-content-container">
			<main id="content" class="mw-body">
				<header class="mw-body-header vector-page-titlebar">
					<nav aria-label="Contents" class="vector-toc-landmark">
						
<div id="vector-page-titlebar-toc" class="vector-dropdown vector-page-titlebar-toc vector-button-flush-left"  >
	<input type="checkbox" id="vector-page-titlebar-toc-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-titlebar-toc" class="vector-dropdown-checkbox "  aria-label="Toggle the table of contents"  >
	<label id="vector-page-titlebar-toc-label" for="vector-page-titlebar-toc-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--icon-only " aria-hidden="true"  ><span class="vector-icon mw-ui-icon-listBullet mw-ui-icon-wikimedia-listBullet"></span>

<span class="vector-dropdown-label-text">Toggle the table of contents</span>
	</label>
	<div class="vector-dropdown-content">


							<div id="vector-page-titlebar-toc-unpinned-container" class="vector-unpinned-container">
			</div>
		
	</div>
</div>

					</nav>
					<h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Logic programming</span></h1>
							
<div id="p-lang-btn" class="vector-dropdown mw-portlet mw-portlet-lang"  >
	<input type="checkbox" id="p-lang-btn-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-p-lang-btn" class="vector-dropdown-checkbox mw-interlanguage-selector" aria-label="Go to an article in another language. Available in 36 languages"   >
	<label id="p-lang-btn-label" for="p-lang-btn-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet cdx-button--action-progressive mw-portlet-lang-heading-36" aria-hidden="true"  ><span class="vector-icon mw-ui-icon-language-progressive mw-ui-icon-wikimedia-language-progressive"></span>

<span class="vector-dropdown-label-text">36 languages</span>
	</label>
	<div class="vector-dropdown-content">

		<div class="vector-menu-content">
			
			<ul class="vector-menu-content-list">
				
				<li class="interlanguage-link interwiki-ar mw-list-item"><a href="https://ar.wikipedia.org/wiki/%D8%A8%D8%B1%D9%85%D8%AC%D8%A9_%D9%85%D9%86%D8%B7%D9%82%D9%8A%D8%A9" title="برمجة منطقية – Arabic" lang="ar" hreflang="ar" data-title="برمجة منطقية" data-language-autonym="العربية" data-language-local-name="Arabic" class="interlanguage-link-target"><span>العربية</span></a></li><li class="interlanguage-link interwiki-bn mw-list-item"><a href="https://bn.wikipedia.org/wiki/%E0%A6%AF%E0%A7%81%E0%A6%95%E0%A7%8D%E0%A6%A4%E0%A6%BF%E0%A6%AD%E0%A6%BF%E0%A6%A4%E0%A7%8D%E0%A6%A4%E0%A6%BF%E0%A6%95_%E0%A6%AA%E0%A7%8D%E0%A6%B0%E0%A7%8B%E0%A6%97%E0%A7%8D%E0%A6%B0%E0%A6%BE%E0%A6%AE%E0%A6%BF%E0%A6%82" title="যুক্তিভিত্তিক প্রোগ্রামিং – Bangla" lang="bn" hreflang="bn" data-title="যুক্তিভিত্তিক প্রোগ্রামিং" data-language-autonym="বাংলা" data-language-local-name="Bangla" class="interlanguage-link-target"><span>বাংলা</span></a></li><li class="interlanguage-link interwiki-bg mw-list-item"><a href="https://bg.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8%D1%80%D0%B0%D0%BD%D0%B5" title="Логическо програмиране – Bulgarian" lang="bg" hreflang="bg" data-title="Логическо програмиране" data-language-autonym="Български" data-language-local-name="Bulgarian" class="interlanguage-link-target"><span>Български</span></a></li><li class="interlanguage-link interwiki-bs mw-list-item"><a href="https://bs.wikipedia.org/wiki/Logi%C4%8Dko_programiranje" title="Logičko programiranje – Bosnian" lang="bs" hreflang="bs" data-title="Logičko programiranje" data-language-autonym="Bosanski" data-language-local-name="Bosnian" class="interlanguage-link-target"><span>Bosanski</span></a></li><li class="interlanguage-link interwiki-ca mw-list-item"><a href="https://ca.wikipedia.org/wiki/Programaci%C3%B3_l%C3%B2gica" title="Programació lògica – Catalan" lang="ca" hreflang="ca" data-title="Programació lògica" data-language-autonym="Català" data-language-local-name="Catalan" class="interlanguage-link-target"><span>Català</span></a></li><li class="interlanguage-link interwiki-cs mw-list-item"><a href="https://cs.wikipedia.org/wiki/Logick%C3%A9_programov%C3%A1n%C3%AD" title="Logické programování – Czech" lang="cs" hreflang="cs" data-title="Logické programování" data-language-autonym="Čeština" data-language-local-name="Czech" class="interlanguage-link-target"><span>Čeština</span></a></li><li class="interlanguage-link interwiki-de mw-list-item"><a href="https://de.wikipedia.org/wiki/Logische_Programmierung" title="Logische Programmierung – German" lang="de" hreflang="de" data-title="Logische Programmierung" data-language-autonym="Deutsch" data-language-local-name="German" class="interlanguage-link-target"><span>Deutsch</span></a></li><li class="interlanguage-link interwiki-et mw-list-item"><a href="https://et.wikipedia.org/wiki/Loogiline_programmeerimine" title="Loogiline programmeerimine – Estonian" lang="et" hreflang="et" data-title="Loogiline programmeerimine" data-language-autonym="Eesti" data-language-local-name="Estonian" class="interlanguage-link-target"><span>Eesti</span></a></li><li class="interlanguage-link interwiki-es mw-list-item"><a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_l%C3%B3gica" title="Programación lógica – Spanish" lang="es" hreflang="es" data-title="Programación lógica" data-language-autonym="Español" data-language-local-name="Spanish" class="interlanguage-link-target"><span>Español</span></a></li><li class="interlanguage-link interwiki-fa mw-list-item"><a href="https://fa.wikipedia.org/wiki/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C_%D9%85%D9%86%D8%B7%D9%82%DB%8C" title="برنامه‌نویسی منطقی – Persian" lang="fa" hreflang="fa" data-title="برنامه‌نویسی منطقی" data-language-autonym="فارسی" data-language-local-name="Persian" class="interlanguage-link-target"><span>فارسی</span></a></li><li class="interlanguage-link interwiki-fr mw-list-item"><a href="https://fr.wikipedia.org/wiki/Programmation_logique" title="Programmation logique – French" lang="fr" hreflang="fr" data-title="Programmation logique" data-language-autonym="Français" data-language-local-name="French" class="interlanguage-link-target"><span>Français</span></a></li><li class="interlanguage-link interwiki-ga mw-list-item"><a href="https://ga.wikipedia.org/wiki/R%C3%ADomhchl%C3%A1r%C3%BA_loighce" title="Ríomhchlárú loighce – Irish" lang="ga" hreflang="ga" data-title="Ríomhchlárú loighce" data-language-autonym="Gaeilge" data-language-local-name="Irish" class="interlanguage-link-target"><span>Gaeilge</span></a></li><li class="interlanguage-link interwiki-gl mw-list-item"><a href="https://gl.wikipedia.org/wiki/Programaci%C3%B3n_l%C3%B3xica" title="Programación lóxica – Galician" lang="gl" hreflang="gl" data-title="Programación lóxica" data-language-autonym="Galego" data-language-local-name="Galician" class="interlanguage-link-target"><span>Galego</span></a></li><li class="interlanguage-link interwiki-ko mw-list-item"><a href="https://ko.wikipedia.org/wiki/%EB%85%BC%EB%A6%AC%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D" title="논리형 프로그래밍 – Korean" lang="ko" hreflang="ko" data-title="논리형 프로그래밍" data-language-autonym="한국어" data-language-local-name="Korean" class="interlanguage-link-target"><span>한국어</span></a></li><li class="interlanguage-link interwiki-hr mw-list-item"><a href="https://hr.wikipedia.org/wiki/Logi%C4%8Dko_programiranje" title="Logičko programiranje – Croatian" lang="hr" hreflang="hr" data-title="Logičko programiranje" data-language-autonym="Hrvatski" data-language-local-name="Croatian" class="interlanguage-link-target"><span>Hrvatski</span></a></li><li class="interlanguage-link interwiki-io mw-list-item"><a href="https://io.wikipedia.org/wiki/Logikala_programigado" title="Logikala programigado – Ido" lang="io" hreflang="io" data-title="Logikala programigado" data-language-autonym="Ido" data-language-local-name="Ido" class="interlanguage-link-target"><span>Ido</span></a></li><li class="interlanguage-link interwiki-it mw-list-item"><a href="https://it.wikipedia.org/wiki/Programmazione_logica" title="Programmazione logica – Italian" lang="it" hreflang="it" data-title="Programmazione logica" data-language-autonym="Italiano" data-language-local-name="Italian" class="interlanguage-link-target"><span>Italiano</span></a></li><li class="interlanguage-link interwiki-he mw-list-item"><a href="https://he.wikipedia.org/wiki/%D7%AA%D7%9B%D7%A0%D7%95%D7%AA_%D7%9C%D7%95%D7%92%D7%99" title="תכנות לוגי – Hebrew" lang="he" hreflang="he" data-title="תכנות לוגי" data-language-autonym="עברית" data-language-local-name="Hebrew" class="interlanguage-link-target"><span>עברית</span></a></li><li class="interlanguage-link interwiki-ms mw-list-item"><a href="https://ms.wikipedia.org/wiki/Pengaturcaraan_logik" title="Pengaturcaraan logik – Malay" lang="ms" hreflang="ms" data-title="Pengaturcaraan logik" data-language-autonym="Bahasa Melayu" data-language-local-name="Malay" class="interlanguage-link-target"><span>Bahasa Melayu</span></a></li><li class="interlanguage-link interwiki-nl mw-list-item"><a href="https://nl.wikipedia.org/wiki/Logisch_programmeren" title="Logisch programmeren – Dutch" lang="nl" hreflang="nl" data-title="Logisch programmeren" data-language-autonym="Nederlands" data-language-local-name="Dutch" class="interlanguage-link-target"><span>Nederlands</span></a></li><li class="interlanguage-link interwiki-ja mw-list-item"><a href="https://ja.wikipedia.org/wiki/%E8%AB%96%E7%90%86%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0" title="論理プログラミング – Japanese" lang="ja" hreflang="ja" data-title="論理プログラミング" data-language-autonym="日本語" data-language-local-name="Japanese" class="interlanguage-link-target"><span>日本語</span></a></li><li class="interlanguage-link interwiki-pl mw-list-item"><a href="https://pl.wikipedia.org/wiki/Programowanie_logiczne" title="Programowanie logiczne – Polish" lang="pl" hreflang="pl" data-title="Programowanie logiczne" data-language-autonym="Polski" data-language-local-name="Polish" class="interlanguage-link-target"><span>Polski</span></a></li><li class="interlanguage-link interwiki-pt mw-list-item"><a href="https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_l%C3%B3gica" title="Programação lógica – Portuguese" lang="pt" hreflang="pt" data-title="Programação lógica" data-language-autonym="Português" data-language-local-name="Portuguese" class="interlanguage-link-target"><span>Português</span></a></li><li class="interlanguage-link interwiki-rue mw-list-item"><a href="https://rue.wikipedia.org/wiki/%D0%9B%D0%BE%D2%91%D1%96%D1%87%D0%BD%D0%B5_%D0%BF%D1%80%D0%BE%D2%91%D1%80%D0%B0%D0%BC%D0%BE%D0%B2%D0%B0%D0%BD%D1%8F" title="Лоґічне проґрамованя – Rusyn" lang="rue" hreflang="rue" data-title="Лоґічне проґрамованя" data-language-autonym="Русиньскый" data-language-local-name="Rusyn" class="interlanguage-link-target"><span>Русиньскый</span></a></li><li class="interlanguage-link interwiki-ru mw-list-item"><a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Логическое программирование – Russian" lang="ru" hreflang="ru" data-title="Логическое программирование" data-language-autonym="Русский" data-language-local-name="Russian" class="interlanguage-link-target"><span>Русский</span></a></li><li class="interlanguage-link interwiki-sq mw-list-item"><a href="https://sq.wikipedia.org/wiki/Programimi_logjik" title="Programimi logjik – Albanian" lang="sq" hreflang="sq" data-title="Programimi logjik" data-language-autonym="Shqip" data-language-local-name="Albanian" class="interlanguage-link-target"><span>Shqip</span></a></li><li class="interlanguage-link interwiki-simple mw-list-item"><a href="https://simple.wikipedia.org/wiki/Logic_programming" title="Logic programming – Simple English" lang="en-simple" hreflang="en-simple" data-title="Logic programming" data-language-autonym="Simple English" data-language-local-name="Simple English" class="interlanguage-link-target"><span>Simple English</span></a></li><li class="interlanguage-link interwiki-sr mw-list-item"><a href="https://sr.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%BA%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8%D1%80%D0%B0%D1%9A%D0%B5" title="Логичко програмирање – Serbian" lang="sr" hreflang="sr" data-title="Логичко програмирање" data-language-autonym="Српски / srpski" data-language-local-name="Serbian" class="interlanguage-link-target"><span>Српски / srpski</span></a></li><li class="interlanguage-link interwiki-fi mw-list-item"><a href="https://fi.wikipedia.org/wiki/Logiikkapohjainen_ohjelmointi" title="Logiikkapohjainen ohjelmointi – Finnish" lang="fi" hreflang="fi" data-title="Logiikkapohjainen ohjelmointi" data-language-autonym="Suomi" data-language-local-name="Finnish" class="interlanguage-link-target"><span>Suomi</span></a></li><li class="interlanguage-link interwiki-sv mw-list-item"><a href="https://sv.wikipedia.org/wiki/Logikprogrammering" title="Logikprogrammering – Swedish" lang="sv" hreflang="sv" data-title="Logikprogrammering" data-language-autonym="Svenska" data-language-local-name="Swedish" class="interlanguage-link-target"><span>Svenska</span></a></li><li class="interlanguage-link interwiki-th mw-list-item"><a href="https://th.wikipedia.org/wiki/%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B9%80%E0%B8%82%E0%B8%B5%E0%B8%A2%E0%B8%99%E0%B9%82%E0%B8%9B%E0%B8%A3%E0%B9%81%E0%B8%81%E0%B8%A3%E0%B8%A1%E0%B9%80%E0%B8%8A%E0%B8%B4%E0%B8%87%E0%B8%95%E0%B8%A3%E0%B8%A3%E0%B8%81%E0%B8%B0" title="การเขียนโปรแกรมเชิงตรรกะ – Thai" lang="th" hreflang="th" data-title="การเขียนโปรแกรมเชิงตรรกะ" data-language-autonym="ไทย" data-language-local-name="Thai" class="interlanguage-link-target"><span>ไทย</span></a></li><li class="interlanguage-link interwiki-tr mw-list-item"><a href="https://tr.wikipedia.org/wiki/Mant%C4%B1k_programlama" title="Mantık programlama – Turkish" lang="tr" hreflang="tr" data-title="Mantık programlama" data-language-autonym="Türkçe" data-language-local-name="Turkish" class="interlanguage-link-target"><span>Türkçe</span></a></li><li class="interlanguage-link interwiki-uk mw-list-item"><a href="https://uk.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D1%96%D1%87%D0%BD%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F" title="Логічне програмування – Ukrainian" lang="uk" hreflang="uk" data-title="Логічне програмування" data-language-autonym="Українська" data-language-local-name="Ukrainian" class="interlanguage-link-target"><span>Українська</span></a></li><li class="interlanguage-link interwiki-vi mw-list-item"><a href="https://vi.wikipedia.org/wiki/L%E1%BA%ADp_tr%C3%ACnh_logic" title="Lập trình logic – Vietnamese" lang="vi" hreflang="vi" data-title="Lập trình logic" data-language-autonym="Tiếng Việt" data-language-local-name="Vietnamese" class="interlanguage-link-target"><span>Tiếng Việt</span></a></li><li class="interlanguage-link interwiki-zh-yue mw-list-item"><a href="https://zh-yue.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E7%B7%A8%E7%A8%8B" title="邏輯編程 – Cantonese" lang="yue" hreflang="yue" data-title="邏輯編程" data-language-autonym="粵語" data-language-local-name="Cantonese" class="interlanguage-link-target"><span>粵語</span></a></li><li class="interlanguage-link interwiki-zh mw-list-item"><a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E7%B7%A8%E7%A8%8B" title="邏輯編程 – Chinese" lang="zh" hreflang="zh" data-title="邏輯編程" data-language-autonym="中文" data-language-local-name="Chinese" class="interlanguage-link-target"><span>中文</span></a></li>
			</ul>
			<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-edit wb-langlinks-link"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q275603#sitelinks-wikipedia" title="Edit interlanguage links" class="wbc-editpage">Edit links</a></span></div>
		</div>

	</div>
</div>
</header>
				<div class="vector-page-toolbar">
					<div class="vector-page-toolbar-container">
						<div id="left-navigation">
							<nav aria-label="Namespaces">
								
<div id="p-associated-pages" class="vector-menu vector-menu-tabs mw-portlet mw-portlet-associated-pages"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="ca-nstab-main" class="selected vector-tab-noicon mw-list-item"><a href="/wiki/Logic_programming" title="View the content page [c]" accesskey="c"><span>Article</span></a></li><li id="ca-talk" class="vector-tab-noicon mw-list-item"><a href="/wiki/Talk:Logic_programming" rel="discussion" title="Discuss improvements to the content page [t]" accesskey="t"><span>Talk</span></a></li>
		</ul>
		
	</div>
</div>

								
<div id="vector-variants-dropdown" class="vector-dropdown emptyPortlet"  >
	<input type="checkbox" id="vector-variants-dropdown-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-variants-dropdown" class="vector-dropdown-checkbox " aria-label="Change language variant"   >
	<label id="vector-variants-dropdown-label" for="vector-variants-dropdown-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet" aria-hidden="true"  ><span class="vector-dropdown-label-text">English</span>
	</label>
	<div class="vector-dropdown-content">


					
<div id="p-variants" class="vector-menu mw-portlet mw-portlet-variants emptyPortlet"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			
		</ul>
		
	</div>
</div>

				
	</div>
</div>

							</nav>
						</div>
						<div id="right-navigation" class="vector-collapsible">
							<nav aria-label="Views">
								
<div id="p-views" class="vector-menu vector-menu-tabs mw-portlet mw-portlet-views"  >
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="ca-view" class="selected vector-tab-noicon mw-list-item"><a href="/wiki/Logic_programming"><span>Read</span></a></li><li id="ca-edit" class="vector-tab-noicon mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;action=edit" title="Edit this page [e]" accesskey="e"><span>Edit</span></a></li><li id="ca-history" class="vector-tab-noicon mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;action=history" title="Past revisions of this page [h]" accesskey="h"><span>View history</span></a></li>
		</ul>
		
	</div>
</div>

							</nav>
				
							<nav class="vector-page-tools-landmark" aria-label="Page tools">
								
<div id="vector-page-tools-dropdown" class="vector-dropdown vector-page-tools-dropdown"  >
	<input type="checkbox" id="vector-page-tools-dropdown-checkbox" role="button" aria-haspopup="true" data-event-name="ui.dropdown-vector-page-tools-dropdown" class="vector-dropdown-checkbox "  aria-label="Tools"  >
	<label id="vector-page-tools-dropdown-label" for="vector-page-tools-dropdown-checkbox" class="vector-dropdown-label cdx-button cdx-button--fake-button cdx-button--fake-button--enabled cdx-button--weight-quiet" aria-hidden="true"  ><span class="vector-dropdown-label-text">Tools</span>
	</label>
	<div class="vector-dropdown-content">


									<div id="vector-page-tools-unpinned-container" class="vector-unpinned-container">
						
<div id="vector-page-tools" class="vector-page-tools vector-pinnable-element">
	<div
	class="vector-pinnable-header vector-page-tools-pinnable-header vector-pinnable-header-unpinned"
	data-feature-name="page-tools-pinned"
	data-pinnable-element-id="vector-page-tools"
	data-pinned-container-id="vector-page-tools-pinned-container"
	data-unpinned-container-id="vector-page-tools-unpinned-container"
>
	<div class="vector-pinnable-header-label">Tools</div>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-page-tools.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-page-tools.unpin">hide</button>
</div>

	
<div id="p-cactions" class="vector-menu mw-portlet mw-portlet-cactions emptyPortlet vector-has-collapsible-items"  title="More options" >
	<div class="vector-menu-heading">
		Actions
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="ca-more-view" class="selected vector-more-collapsible-item mw-list-item"><a href="/wiki/Logic_programming"><span>Read</span></a></li><li id="ca-more-edit" class="vector-more-collapsible-item mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;action=edit" title="Edit this page [e]" accesskey="e"><span>Edit</span></a></li><li id="ca-more-history" class="vector-more-collapsible-item mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;action=history"><span>View history</span></a></li>
		</ul>
		
	</div>
</div>

<div id="p-tb" class="vector-menu mw-portlet mw-portlet-tb"  >
	<div class="vector-menu-heading">
		General
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="t-whatlinkshere" class="mw-list-item"><a href="/wiki/Special:WhatLinksHere/Logic_programming" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j"><span>What links here</span></a></li><li id="t-recentchangeslinked" class="mw-list-item"><a href="/wiki/Special:RecentChangesLinked/Logic_programming" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k"><span>Related changes</span></a></li><li id="t-upload" class="mw-list-item"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Upload files [u]" accesskey="u"><span>Upload file</span></a></li><li id="t-specialpages" class="mw-list-item"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q"><span>Special pages</span></a></li><li id="t-permalink" class="mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;oldid=1259279203" title="Permanent link to this revision of this page"><span>Permanent link</span></a></li><li id="t-info" class="mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;action=info" title="More information about this page"><span>Page information</span></a></li><li id="t-cite" class="mw-list-item"><a href="/w/index.php?title=Special:CiteThisPage&amp;page=Logic_programming&amp;id=1259279203&amp;wpFormIdentifier=titleform" title="Information on how to cite this page"><span>Cite this page</span></a></li><li id="t-urlshortener" class="mw-list-item"><a href="/w/index.php?title=Special:UrlShortener&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLogic_programming"><span>Get shortened URL</span></a></li><li id="t-urlshortener-qrcode" class="mw-list-item"><a href="/w/index.php?title=Special:QrCode&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLogic_programming"><span>Download QR code</span></a></li>
		</ul>
		
	</div>
</div>

<div id="p-coll-print_export" class="vector-menu mw-portlet mw-portlet-coll-print_export"  >
	<div class="vector-menu-heading">
		Print/export
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li id="coll-download-as-rl" class="mw-list-item"><a href="/w/index.php?title=Special:DownloadAsPdf&amp;page=Logic_programming&amp;action=show-download-screen" title="Download this page as a PDF file"><span>Download as PDF</span></a></li><li id="t-print" class="mw-list-item"><a href="/w/index.php?title=Logic_programming&amp;printable=yes" title="Printable version of this page [p]" accesskey="p"><span>Printable version</span></a></li>
		</ul>
		
	</div>
</div>

<div id="p-wikibase-otherprojects" class="vector-menu mw-portlet mw-portlet-wikibase-otherprojects"  >
	<div class="vector-menu-heading">
		In other projects
	</div>
	<div class="vector-menu-content">
		
		<ul class="vector-menu-content-list">
			
			<li class="wb-otherproject-link wb-otherproject-commons mw-list-item"><a href="https://commons.wikimedia.org/wiki/Category:Logic_programming" hreflang="en"><span>Wikimedia Commons</span></a></li><li id="t-wikibase" class="wb-otherproject-link wb-otherproject-wikibase-dataitem mw-list-item"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q275603" title="Structured data on this page hosted by Wikidata [g]" accesskey="g"><span>Wikidata item</span></a></li>
		</ul>
		
	</div>
</div>

</div>

									</div>
				
	</div>
</div>

							</nav>
						</div>
					</div>
				</div>
				<div class="vector-column-end">
					<div class="vector-sticky-pinned-container">
						<nav class="vector-page-tools-landmark" aria-label="Page tools">
							<div id="vector-page-tools-pinned-container" class="vector-pinned-container">
				
							</div>
		</nav>
						<nav class="vector-appearance-landmark" aria-label="Appearance">
							<div id="vector-appearance-pinned-container" class="vector-pinned-container">
				<div id="vector-appearance" class="vector-appearance vector-pinnable-element">
	<div
	class="vector-pinnable-header vector-appearance-pinnable-header vector-pinnable-header-pinned"
	data-feature-name="appearance-pinned"
	data-pinnable-element-id="vector-appearance"
	data-pinned-container-id="vector-appearance-pinned-container"
	data-unpinned-container-id="vector-appearance-unpinned-container"
>
	<div class="vector-pinnable-header-label">Appearance</div>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-pin-button" data-event-name="pinnable-header.vector-appearance.pin">move to sidebar</button>
	<button class="vector-pinnable-header-toggle-button vector-pinnable-header-unpin-button" data-event-name="pinnable-header.vector-appearance.unpin">hide</button>
</div>


</div>

							</div>
		</nav>
					</div>
				</div>
				<div id="bodyContent" class="vector-body" aria-labelledby="firstHeading" data-mw-ve-target-container>
					<div class="vector-body-before-content">
							<div class="mw-indicators">
		</div>

						<div id="siteSub" class="noprint">From Wikipedia, the free encyclopedia</div>
					</div>
					<div id="contentSub"><div id="mw-content-subtitle"></div></div>
					
					
					<div id="mw-content-text" class="mw-body-content"><div class="mw-content-ltr mw-parser-output" lang="en" dir="ltr"><div class="shortdescription nomobile noexcerpt noprint searchaux" style="display:none">Programming paradigm based on formal logic</div>
<p><b>Logic programming</b> is a <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming</a>, <a href="/wiki/Database" title="Database">database</a> and <a href="/wiki/Knowledge_representation" class="mw-redirect" title="Knowledge representation">knowledge representation</a> paradigm based on formal <a href="/wiki/Logic" title="Logic">logic</a>. A logic program is a set of sentences in logical form, representing knowledge about some problem domain. Computation is performed by applying logical reasoning to that knowledge, to solve problems in the domain.  Major logic programming language families include <a href="/wiki/Prolog" title="Prolog">Prolog</a>, <a href="/wiki/Answer_set_programming" title="Answer set programming">Answer Set Programming</a> (ASP) and <a href="/wiki/Datalog" title="Datalog">Datalog</a>. In all of these languages, rules are written in the form of <i><a href="/wiki/Clause_(logic)" title="Clause (logic)">clauses</a></i>:
</p>
<dl><dd><code>A&#160;:- B<sub>1</sub>, ..., B<sub>n</sub>.</code></dd></dl>
<p>and are read as declarative sentences in logical form:
</p>
<dl><dd><code>A if B<sub>1</sub> and ... and B<sub>n</sub>.</code></dd></dl>
<p><code>A</code> is called the <i>head</i> of the rule, <code>B<sub>1</sub></code>, ..., <code>B<sub>n</sub></code> is called the <i>body</i>, and the <code>B<sub>i</sub></code> are called <i><a href="/wiki/Literal_(mathematical_logic)" title="Literal (mathematical logic)">literals</a></i> or conditions. When n = 0, the rule is called a <i>fact</i> and is written in the simplified form:
</p>
<dl><dd><code>A.</code></dd></dl>
<p>Queries (or goals) have the same syntax as the bodies of rules and are commonly written in the form:
</p>
<dl><dd><code>?- B<sub>1</sub>, ..., B<sub>n</sub>.</code></dd></dl>
<p>In the simplest case of <a href="/wiki/Horn_clause" title="Horn clause">Horn clauses</a> (or "definite" clauses), all of the A, B<sub>1</sub>, ..., B<sub>n</sub> are <a href="/wiki/Atomic_formula" title="Atomic formula">atomic formulae</a> of the form p(t<sub>1</sub> ,..., t<sub>m</sub>), where p is a predicate symbol naming a relation, like "motherhood", and the t<sub>i</sub> are terms naming objects (or individuals). Terms include both constant symbols, like "charles", and variables, such as X, which start with an upper case letter.
</p><p>Consider, for example, the following Horn clause program:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">mother_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">charles</span><span class="p">).</span>
<span class="nf">father_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">father_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">mother_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">father_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">grandparent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">parent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> 
     <span class="nf">parent_child</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
<p>Given a query, the program produces answers.
For instance for a query  <code>?- parent_child(X, william)</code>, the single answer is
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">charles</span>
</pre></div>
<p>Various queries can be asked.  For instance
the program can be queried both to generate grandparents and to generate grandchildren. It can even be used to generate all pairs of grandchildren and grandparents, or simply to check if a given pair is such a pair:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">grandparent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">elizabeth</span>

<span class="s s-Atom">?-</span> <span class="nf">grandparent_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="s s-Atom">william</span><span class="p">;</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="s s-Atom">harry</span><span class="p">.</span>

<span class="s s-Atom">?-</span> <span class="nf">grandparent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">elizabeth</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="s s-Atom">william</span><span class="p">;</span>
<span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">elizabeth</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="s s-Atom">harry</span><span class="p">.</span>

<span class="s s-Atom">?-</span> <span class="nf">grandparent_child</span><span class="p">(</span><span class="s s-Atom">william</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
<span class="s s-Atom">no</span>
<span class="s s-Atom">?-</span> <span class="nf">grandparent_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
<span class="s s-Atom">yes</span>
</pre></div>
<p>Although Horn clause logic programs are <a href="/wiki/Turing_completeness" title="Turing completeness">Turing complete</a>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span class="cite-bracket">&#91;</span>1<span class="cite-bracket">&#93;</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span class="cite-bracket">&#91;</span>2<span class="cite-bracket">&#93;</span></a></sup> for most practical applications, Horn clause programs need to be extended to "normal" logic programs with negative conditions. For example, the definition of sibling uses a negative condition, where the <a href="/wiki/Predicate_(mathematical_logic)" title="Predicate (mathematical logic)">predicate</a> = is defined by the clause <code> X = X </code>:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">sibling</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">parent_child</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> 
     <span class="nf">parent_child</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> 
     <span class="o">not</span><span class="p">(</span><span class="nv">X</span> <span class="o">=</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
<p>Logic programming languages that include negative conditions have the knowledge representation capabilities of a <a href="/wiki/Non-monotonic_logic" title="Non-monotonic logic">non-monotonic logic</a>.
</p><p>In ASP and Datalog, logic programs have only a <a href="/wiki/Declarative_programming" title="Declarative programming">declarative</a> reading, and their execution is performed by means of a proof procedure or model generator whose behaviour is not meant to be controlled by the programmer. However, in the Prolog family of languages, logic programs also have a <a href="/wiki/Procedural_programming" title="Procedural programming">procedural</a> interpretation as goal-reduction procedures. From this point of view, clause A&#160;:- B<sub>1</sub>,...,B<sub>n</sub> is understood as:
</p>
<dl><dd>to solve <code>A</code>, solve <code>B<sub>1</sub></code>, and ... and solve <code>B<sub>n</sub></code>.</dd></dl>
<p>Negative conditions in the bodies of clauses also have a procedural interpretation, known as <i><a href="/wiki/Negation_as_failure" title="Negation as failure">negation as failure</a></i>: A negative literal <code> not B</code> is deemed to hold if and only if the positive literal <code> B</code> fails to hold.
</p><p>Much of the research in the field of logic programming has been concerned with trying to develop a logical semantics for negation as failure and with developing other semantics and other implementations for negation. These developments have been important, in turn, for supporting the development of <a href="/wiki/Formal_methods" title="Formal methods">formal methods</a> for logic-based <a href="/wiki/Formal_verification" title="Formal verification">program verification</a> and <a href="/wiki/Program_transformation" title="Program transformation">program transformation</a>.
</p>
<meta property="mw:PageProp/toc" />
<div class="mw-heading mw-heading2"><h2 id="History">History</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=1" title="Edit section: History"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>The use of mathematical logic to represent and execute <a href="/wiki/Computer_program" title="Computer program">computer programs</a> is also a feature of the <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>, developed by <a href="/wiki/Alonzo_Church" title="Alonzo Church">Alonzo Church</a> in the 1930s. However, the first proposal to use the <a href="/wiki/Clausal_normal_form" class="mw-redirect" title="Clausal normal form">clausal</a> form of logic for representing computer programs was made by <a href="/wiki/Cordell_Green" title="Cordell Green">Cordell Green</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span class="cite-bracket">&#91;</span>3<span class="cite-bracket">&#93;</span></a></sup> This used an axiomatization of a subset of <a href="/wiki/LISP" class="mw-redirect" title="LISP">LISP</a>, together with a representation of an input-output relation, to compute the relation by simulating the execution of the program in LISP. Foster and Elcock's <a href="/wiki/Absys" title="Absys">Absys</a>, on the other hand, employed a combination of equations and lambda calculus in an assertional programming language that places no constraints on the order in which operations are performed.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span class="cite-bracket">&#91;</span>4<span class="cite-bracket">&#93;</span></a></sup>
</p><p>Logic programming, with its current syntax of facts and rules, can be traced back to debates in the late 1960s and early 1970s about declarative versus procedural representations of knowledge in <a href="/wiki/Artificial_intelligence" title="Artificial intelligence">artificial intelligence</a>. Advocates of declarative representations were notably working at <a href="/wiki/Stanford_University" title="Stanford University">Stanford</a>, associated with <a href="/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a>, <a href="/wiki/Bertram_Raphael" title="Bertram Raphael">Bertram Raphael</a> and Cordell Green, and in <a href="/wiki/University_of_Edinburgh" title="University of Edinburgh">Edinburgh</a>, with <a href="/wiki/John_Alan_Robinson" title="John Alan Robinson">John Alan Robinson</a> (an academic visitor from <a href="/wiki/Syracuse_University" title="Syracuse University">Syracuse University</a>), <a href="/wiki/Patrick_J._Hayes" class="mw-redirect" title="Patrick J. Hayes">Pat Hayes</a>, and <a href="/wiki/Robert_Kowalski" title="Robert Kowalski">Robert Kowalski</a>. Advocates of procedural representations were mainly centered at <a href="/wiki/MIT" class="mw-redirect" title="MIT">MIT</a>, under the leadership of <a href="/wiki/Marvin_Minsky" title="Marvin Minsky">Marvin Minsky</a> and <a href="/wiki/Seymour_Papert" title="Seymour Papert">Seymour Papert</a>.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span class="cite-bracket">&#91;</span>5<span class="cite-bracket">&#93;</span></a></sup>
</p><p>Although it was based on the proof methods of logic, <a href="/wiki/Planner_(programming_language)" title="Planner (programming language)">Planner</a>, developed by <a href="/wiki/Carl_Hewitt" title="Carl Hewitt">Carl Hewitt</a> at MIT, was the first language to emerge within this proceduralist paradigm.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span class="cite-bracket">&#91;</span>6<span class="cite-bracket">&#93;</span></a></sup> Planner featured pattern-directed invocation of procedural plans from goals (i.e. goal-reduction or <a href="/wiki/Backward_chaining" title="Backward chaining">backward chaining</a>) and from assertions (i.e. <a href="/wiki/Forward_chaining" title="Forward chaining">forward chaining</a>). The most influential implementation of Planner was the subset of Planner, called Micro-Planner, implemented by <a href="/wiki/Gerald_Jay_Sussman" title="Gerald Jay Sussman">Gerry Sussman</a>, <a href="/wiki/Eugene_Charniak" title="Eugene Charniak">Eugene Charniak</a> and <a href="/wiki/Terry_Winograd" title="Terry Winograd">Terry Winograd</a>. Winograd used Micro-Planner to implement the landmark, natural-language understanding program <a href="/wiki/SHRDLU" title="SHRDLU">SHRDLU</a>.<sup id="cite_ref-Winograd_7-0" class="reference"><a href="#cite_note-Winograd-7"><span class="cite-bracket">&#91;</span>7<span class="cite-bracket">&#93;</span></a></sup> For the sake of efficiency, Planner used a backtracking control structure so that only one possible computation path had to be stored at a time. Planner gave rise to the programming languages <a href="/wiki/Richard_Waldinger#QA4" title="Richard Waldinger">QA4</a>,<sup id="cite_ref-Rulifson_8-0" class="reference"><a href="#cite_note-Rulifson-8"><span class="cite-bracket">&#91;</span>8<span class="cite-bracket">&#93;</span></a></sup> Popler,<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span class="cite-bracket">&#91;</span>9<span class="cite-bracket">&#93;</span></a></sup> Conniver,<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span class="cite-bracket">&#91;</span>10<span class="cite-bracket">&#93;</span></a></sup> QLISP,<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span class="cite-bracket">&#91;</span>11<span class="cite-bracket">&#93;</span></a></sup> and the concurrent language Ether.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span class="cite-bracket">&#91;</span>12<span class="cite-bracket">&#93;</span></a></sup>
</p><p>Hayes and Kowalski in Edinburgh tried to reconcile the logic-based declarative approach to knowledge representation with Planner's procedural approach. Hayes (1973) developed an equational language, Golux, in which different procedures could be obtained by altering the behavior of the theorem prover.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span class="cite-bracket">&#91;</span>13<span class="cite-bracket">&#93;</span></a></sup>
</p><p>In the meanwhile, <a href="/wiki/Alain_Colmerauer" title="Alain Colmerauer">Alain Colmerauer</a> in <a href="/wiki/Marseille" title="Marseille">Marseille</a> was working on <a href="/wiki/Natural-language_understanding" class="mw-redirect" title="Natural-language understanding">natural-language understanding</a>, using logic to represent semantics and using resolution for question-answering. During the summer of 1971, Colmerauer invited Kowalski to Marseille, and together they discovered that the clausal form of logic could be used to represent <a href="/wiki/Formal_grammars" class="mw-redirect" title="Formal grammars">formal grammars</a> and that resolution theorem provers could be used for parsing. They observed that some theorem provers, like hyper-resolution,<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span class="cite-bracket">&#91;</span>14<span class="cite-bracket">&#93;</span></a></sup> behave as bottom-up parsers and others, like <a href="/wiki/SLD_resolution" title="SLD resolution">SL resolution</a> (1971)<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span class="cite-bracket">&#91;</span>15<span class="cite-bracket">&#93;</span></a></sup> behave as top-down parsers.
</p><p>It was in the following summer of 1972, that Kowalski, again working with Colmerauer, developed the procedural interpretation of implications in clausal form. It also became clear that such clauses could be restricted to definite clauses or <a href="/wiki/Horn_clause" title="Horn clause">Horn clauses</a>, and that SL-resolution could be restricted (and generalised) to <a href="/wiki/SLD_resolution" title="SLD resolution">SLD resolution</a>. Kowalski's procedural interpretation and SLD were described in a 1973 memo, published in 1974.<sup id="cite_ref-Kowalski_16-0" class="reference"><a href="#cite_note-Kowalski-16"><span class="cite-bracket">&#91;</span>16<span class="cite-bracket">&#93;</span></a></sup>
</p><p>Colmerauer, with Philippe Roussel, used the procedural interpretation as the basis of Prolog, which was implemented in the summer and autumn of 1972. The first Prolog program, also written in 1972 and implemented in Marseille, was a French question-answering system. The use of Prolog as a practical programming language was given great momentum by the development of a compiler by <a href="/wiki/David_H._D._Warren" title="David H. D. Warren">David H. D. Warren</a> in Edinburgh in 1977. Experiments demonstrated that Edinburgh Prolog could compete with the processing speed of other <a href="/wiki/Symbolic_programming" title="Symbolic programming">symbolic programming</a> languages such as <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>.<sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span class="cite-bracket">&#91;</span>17<span class="cite-bracket">&#93;</span></a></sup> Edinburgh Prolog became the <i>de facto</i> standard and strongly influenced the definition of <a href="/wiki/International_Organization_for_Standardization" title="International Organization for Standardization">ISO</a> standard Prolog.
</p><p>Logic programming gained international attention during the 1980s, when it was chosen by the Japanese  <a href="/wiki/Ministry_of_International_Trade_and_Industry" title="Ministry of International Trade and Industry">Ministry of International Trade and Industry</a> to develop the software for the <a href="/wiki/Fifth_Generation_Computer_Systems" title="Fifth Generation Computer Systems">Fifth Generation Computer Systems</a> (FGCS) project. The FGCS project aimed to use logic programming to develop advanced <a href="/wiki/Artificial_Intelligence" class="mw-redirect" title="Artificial Intelligence">Artificial Intelligence</a> applications on massively <a href="/wiki/Parallel_computing" title="Parallel computing">parallel computers</a>. Although the project initially explored the use of Prolog, it later adopted the use of <a href="/wiki/Concurrent_logic_programming" title="Concurrent logic programming">concurrent logic programming</a>, because it was closer to the FGCS computer architecture.
</p><p>However, the committed choice feature of concurrent logic programming interfered with the language's logical semantics<sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span class="cite-bracket">&#91;</span>18<span class="cite-bracket">&#93;</span></a></sup> and with its suitability for knowledge representation and problem solving applications. Moreover, the parallel computer systems developed in the project failed to compete with advances taking place in the development of more conventional, general-purpose computers. Together these two issues resulted in the FGCS project failing to meet its objectives. Interest in both logic programming and AI fell into world-wide decline.<sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span class="cite-bracket">&#91;</span>19<span class="cite-bracket">&#93;</span></a></sup>
</p><p>In the meanwhile, more declarative logic programming approaches, including those based on the use of Prolog, continued to make progress independently of the FGCS project. In particular, although Prolog was developed to combine declarative and procedural representations of knowledge, the purely declarative interpretation of logic programs became the focus for applications in the field of <a href="/wiki/Deductive_database" title="Deductive database">deductive databases</a>. Work in this field became prominent around 1977, when Hervé Gallaire and <a href="/wiki/Jack_Minker" title="Jack Minker">Jack Minker</a> organized a workshop on logic and databases in Toulouse.<sup id="cite_ref-20" class="reference"><a href="#cite_note-20"><span class="cite-bracket">&#91;</span>20<span class="cite-bracket">&#93;</span></a></sup> The field was eventually renamed as <i><a href="/wiki/Datalog" title="Datalog">Datalog</a></i>.
</p><p>This focus on the logical, declarative reading of logic programs was given further impetus by the development of <a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">constraint logic programming</a> in the 1980s and <a href="/wiki/Answer_set_programming" title="Answer set programming">Answer Set Programming</a> in the 1990s. It is also receiving renewed emphasis in recent applications of Prolog<sup id="cite_ref-Prolog_Book_21-0" class="reference"><a href="#cite_note-Prolog_Book-21"><span class="cite-bracket">&#91;</span>21<span class="cite-bracket">&#93;</span></a></sup>
</p><p>The <a href="/wiki/Association_for_Logic_Programming" title="Association for Logic Programming">Association for Logic Programming</a> (ALP) was founded in 1986 to promote Logic Programming. Its official journal until 2000, was <i><a href="/wiki/The_Journal_of_Logic_Programming" class="mw-redirect" title="The Journal of Logic Programming">The Journal of Logic Programming</a></i>. Its  founding <a href="/wiki/Editor-in-chief" title="Editor-in-chief">editor-in-chief</a> was <a href="/wiki/J._Alan_Robinson" class="mw-redirect" title="J. Alan Robinson">J. Alan Robinson</a>.<sup id="cite_ref-22" class="reference"><a href="#cite_note-22"><span class="cite-bracket">&#91;</span>22<span class="cite-bracket">&#93;</span></a></sup>  In 2001, the journal was renamed <i>The Journal of Logic and Algebraic Programming</i>, and the official journal of ALP became <i><a href="/wiki/Theory_and_Practice_of_Logic_Programming" class="mw-redirect" title="Theory and Practice of Logic Programming">Theory and Practice of Logic Programming</a></i>, published by <a href="/wiki/Cambridge_University_Press" title="Cambridge University Press">Cambridge University Press</a>.
</p>
<div class="mw-heading mw-heading2"><h2 id="Concepts">Concepts</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=2" title="Edit section: Concepts"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>Logic programs enjoy a rich variety of semantics and problem solving methods, as well as a wide range of applications in programming, databases, knowledge representation and problem solving.
</p>
<div class="mw-heading mw-heading3"><h3 id="Algorithm_=_Logic_+_Control"><span id="Algorithm_.3D_Logic_.2B_Control"></span>Algorithm = Logic + Control</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=3" title="Edit section: Algorithm = Logic + Control"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>The procedural interpretation of logic programs, which uses backward reasoning to reduce goals to subgoals, is a special case of the use of a problem-solving strategy to <b>control</b> the use of a declarative, <b>logical</b> representation of knowledge to obtain the behaviour of an <b>algorithm</b>. More generally, different problem-solving strategies can be applied to the same logical representation to obtain different algorithms. Alternatively, different algorithms can be obtained with a given problem-solving strategy by using different logical representations.<sup id="cite_ref-23" class="reference"><a href="#cite_note-23"><span class="cite-bracket">&#91;</span>23<span class="cite-bracket">&#93;</span></a></sup>
</p><p>The two main problem-solving strategies are <a href="/wiki/Backward_chaining" title="Backward chaining">backward reasoning</a> (goal reduction) and <a href="/wiki/Forward_chaining" title="Forward chaining">forward reasoning</a>, also known as top-down and bottom-up reasoning, respectively.
</p><p>In the simple case of a propositional Horn clause program and a top-level atomic goal, backward reasoning determines an <a href="/wiki/And-or_tree" class="mw-redirect" title="And-or tree">and-or tree</a>, which constitutes the search space for solving the goal. The top-level goal is the root of the tree. Given any node in the tree and any clause whose head matches the node, there exists a set of child nodes corresponding to the sub-goals in the body of the clause. These child nodes are grouped together by an "and". The alternative sets of children corresponding to alternative ways of solving the node are grouped together by an "or".
</p><p>Any search strategy can be used to search this space. Prolog uses a sequential, last-in-first-out, backtracking strategy, in which only one alternative and one sub-goal are considered at a time. For example, subgoals can be solved in parallel, and clauses can also be tried in parallel. The first strategy is called <b><style data-mw-deduplicate="TemplateStyles:r1238216509">.mw-parser-output .vanchor>:target~.vanchor-text{background-color:#b1d2ff}@media screen{html.skin-theme-clientpref-night .mw-parser-output .vanchor>:target~.vanchor-text{background-color:#0f4dc9}}@media screen and (prefers-color-scheme:dark){html.skin-theme-clientpref-os .mw-parser-output .vanchor>:target~.vanchor-text{background-color:#0f4dc9}}</style><span class="vanchor"><span id="and-parallel"></span><span class="vanchor-text">and-parallel</span></span></b> and the second strategy is called <b><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238216509"><span class="vanchor"><span id="or-parallel"></span><span class="vanchor-text">or-parallel</span></span></b>. Other search strategies, such as intelligent backtracking,<sup id="cite_ref-24" class="reference"><a href="#cite_note-24"><span class="cite-bracket">&#91;</span>24<span class="cite-bracket">&#93;</span></a></sup> or best-first search to find an optimal solution,<sup id="cite_ref-25" class="reference"><a href="#cite_note-25"><span class="cite-bracket">&#91;</span>25<span class="cite-bracket">&#93;</span></a></sup> are also possible.
</p><p>In the more general, non-propositional case, where sub-goals can share variables, other strategies can be used, such as choosing the subgoal that is most highly instantiated or that is sufficiently instantiated so that only one procedure applies.<sup id="cite_ref-26" class="reference"><a href="#cite_note-26"><span class="cite-bracket">&#91;</span>26<span class="cite-bracket">&#93;</span></a></sup> Such strategies are used, for example, in <a href="/wiki/Concurrent_logic_programming" title="Concurrent logic programming">concurrent logic programming</a>.
</p><p>In most cases, backward reasoning from a query or goal is more efficient than forward reasoning. But sometimes with Datalog and Answer Set Programming, there may be no query that is separate from the set of clauses as a whole, and then generating all the facts that can be derived from the clauses is a sensible problem-solving strategy. Here is another example, where forward reasoning beats backward reasoning in a more conventional computation task, where the goal <code>?- fibonacci(n, Result)</code> is to find the n<sup>th</sup> fibonacci number:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>

<span class="nf">fibonacci</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Result</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nv">N1</span> <span class="o">is</span> <span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nv">N2</span> <span class="o">is</span> <span class="nv">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
    <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">N1</span><span class="p">,</span> <span class="nv">F1</span><span class="p">),</span>
    <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">N2</span><span class="p">,</span> <span class="nv">F2</span><span class="p">),</span>
    <span class="nv">Result</span> <span class="o">is</span> <span class="nv">F1</span> <span class="o">+</span> <span class="nv">F2</span><span class="p">.</span>
</pre></div>
<p>Here the relation <code>fibonacci(N, M)</code> stands for the function <code>fibonacci(N) = M</code>, and the predicate <code>N is Expression</code> is Prolog notation for the predicate that instantiates the variable <code>N</code> to the value of <code>Expression</code>.
</p><p>Given the goal of computing the fibonacci number of <code>n</code>, backward reasoning reduces the goal to the two subgoals of computing the fibonacci numbers of n-1 and n-2. It reduces the subgoal of computing the fibonacci number of n-1 to the two subgoals of computing the fibonacci numbers of n-2 and n-3, redundantly computing the fibonacci number of n-2. This process of reducing one fibonacci subgoal to two fibonacci subgoals continues until it reaches the numbers 0 and 1. Its complexity is of the order 2<sup>n</sup>. In contrast, forward reasoning generates the sequence of fibonacci numbers, starting from 0 and 1 without any recomputation, and its complexity is linear with respect to n.
</p><p>Prolog cannot perform forward reasoning directly. But it can achieve the effect of forward reasoning within the context of backward reasoning by means of <a href="/wiki/Tabling" class="mw-redirect" title="Tabling">tabling</a>: Subgoals are maintained in a table, along with their solutions. If a subgoal is re-encountered, it is solved directly by using the solutions already in the table, instead of re-solving the subgoals redundantly.<sup id="cite_ref-27" class="reference"><a href="#cite_note-27"><span class="cite-bracket">&#91;</span>27<span class="cite-bracket">&#93;</span></a></sup>
</p>
<div class="mw-heading mw-heading3"><h3 id="Relationship_with_functional_programming">Relationship with functional programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=4" title="Edit section: Relationship with functional programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<style data-mw-deduplicate="TemplateStyles:r1236090951">.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}@media print{body.ns-0 .mw-parser-output .hatnote{display:none!important}}</style><div role="note" class="hatnote navigation-not-searchable">See also: <a href="/wiki/Functional_programming#Comparison_to_logic_programming" title="Functional programming">Functional programming §&#160;Comparison to logic programming</a></div>
<p>Logic programming can be viewed as a generalisation of functional programming, in which functions are a special case of relations.<sup id="cite_ref-dis_28-0" class="reference"><a href="#cite_note-dis-28"><span class="cite-bracket">&#91;</span>28<span class="cite-bracket">&#93;</span></a></sup>
For example, the function, mother(X) = Y, (every X has only one mother Y) can be represented by the relation mother(X, Y). In this respect, logic programs are similar to <a href="/wiki/Relational_databases" class="mw-redirect" title="Relational databases">relational databases</a>, which also represent functions as relations.
</p><p>Compared with relational syntax, functional syntax is more compact for nested functions. For example, in functional syntax the definition of maternal grandmother can be written in the nested form:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">maternal_grandmother</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">=</span> <span class="nf">mother</span><span class="p">(</span><span class="nf">mother</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
</pre></div>
<p>The same definition in relational notation needs to be written in the unnested, flattened form:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">maternal_grandmother</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">mother</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">mother</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
<p>However, nested syntax can be regarded as syntactic sugar for unnested syntax. <a href="/wiki/Ciao_(programming_language)" title="Ciao (programming language)">Ciao</a> Prolog, for example, transforms functional syntax into relational form and executes the resulting logic program using the standard Prolog execution strategy.<sup id="cite_ref-29" class="reference"><a href="#cite_note-29"><span class="cite-bracket">&#91;</span>29<span class="cite-bracket">&#93;</span></a></sup> Moreover, the same transformation can be used to execute nested relations that are not functional. For example:
</p>
  <div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">grandparent</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="nf">parent</span><span class="p">(</span><span class="nf">parent</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="nf">parent</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="nf">mother</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">parent</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="nf">father</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>

<span class="nf">mother</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="s s-Atom">elizabeth</span><span class="p">.</span>
<span class="nf">father</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="s s-Atom">phillip</span><span class="p">.</span>
<span class="nf">mother</span><span class="p">(</span><span class="s s-Atom">harry</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="s s-Atom">diana</span><span class="p">.</span>
<span class="nf">father</span><span class="p">(</span><span class="s s-Atom">harry</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="s s-Atom">charles</span><span class="p">.</span>

<span class="s s-Atom">?-</span> <span class="nf">grandparent</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">harry</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="s s-Atom">elizabeth</span><span class="p">.</span>
<span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">harry</span><span class="p">,</span>
<span class="nv">Y</span> <span class="o">=</span> <span class="s s-Atom">phillip</span><span class="p">.</span>
</pre></div>
<div class="mw-heading mw-heading3"><h3 id="Relationship_with_relational_programming">Relationship with relational programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=5" title="Edit section: Relationship with relational programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>The term <i>relational programming</i> has been used to cover a variety of programming languages that treat functions as a special case of relations. Some of these languages, such as <a href="/wiki/MiniKanren" title="MiniKanren">miniKanren</a><sup id="cite_ref-dis_28-1" class="reference"><a href="#cite_note-dis-28"><span class="cite-bracket">&#91;</span>28<span class="cite-bracket">&#93;</span></a></sup>
and relational linear programming<sup id="cite_ref-30" class="reference"><a href="#cite_note-30"><span class="cite-bracket">&#91;</span>30<span class="cite-bracket">&#93;</span></a></sup>
are logic programming languages in the sense of this article.
</p><p>However, the relational language RML is an imperative programming language
<sup id="cite_ref-31" class="reference"><a href="#cite_note-31"><span class="cite-bracket">&#91;</span>31<span class="cite-bracket">&#93;</span></a></sup> whose core construct is a
relational expression, which is similar to an expression in first-order predicate logic.
</p><p>Other relational programming languages are based on the relational calculus<sup id="cite_ref-32" class="reference"><a href="#cite_note-32"><span class="cite-bracket">&#91;</span>32<span class="cite-bracket">&#93;</span></a></sup> or relational algebra.<sup id="cite_ref-33" class="reference"><a href="#cite_note-33"><span class="cite-bracket">&#91;</span>33<span class="cite-bracket">&#93;</span></a></sup>
</p>
<div class="mw-heading mw-heading3"><h3 id="Semantics_of_Horn_clause_programs">Semantics of Horn clause programs</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=6" title="Edit section: Semantics of Horn clause programs"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Syntax_and_semantics_of_logic_programming" title="Syntax and semantics of logic programming">Syntax and semantics of logic programming</a></div>
<p>Viewed in purely logical terms, there are two approaches to the declarative semantics of Horn clause logic programs: One approach is the original <i><a href="/wiki/Logical_consequence" title="Logical consequence">logical consequence</a> semantics</i>, which understands solving a goal as showing that the goal is a theorem that is true in all <a href="/wiki/Structure_(mathematical_logic)#Structures_and_first-order_logic" title="Structure (mathematical logic)">models</a> of the program.
</p><p>In this approach, computation is <a href="/wiki/Automated_theorem_proving" title="Automated theorem proving">theorem-proving</a> in <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a>; and both <a href="/wiki/Backward_chaining" title="Backward chaining">backward reasoning</a>, as in SLD resolution, and <a href="/wiki/Forward_chaining" title="Forward chaining">forward reasoning</a>, as in hyper-resolution,  are correct and complete theorem-proving methods.  Sometimes such theorem-proving methods are also regarded as providing a separate <a href="/wiki/Proof-theoretic_semantics" title="Proof-theoretic semantics">proof-theoretic (or operational) semantics</a> for logic programs. But from a logical point of view, they are proof methods, rather than semantics.
</p><p>The other approach to the declarative semantics of Horn clause programs is the <i><a href="/wiki/Satisfiability" title="Satisfiability">satisfiability</a> semantics</i>, which understands solving a goal as showing that the goal is true (or satisfied) in some <a href="/wiki/Intended_interpretation" class="mw-redirect" title="Intended interpretation">intended (or standard) model</a> of the program. For Horn clause programs, there always exists such a standard model: It is the unique <i>minimal model</i> of the program.
</p><p>Informally speaking, a minimal model is a model that, when it is viewed as the set of all (variable-free) facts that are true in the model, contains no smaller set of facts that is also a model of the program.
</p><p>For example, the following facts represent the minimal model of the family relationships example in the introduction of this article. All other variable-free facts are false in the model:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">mother_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">charles</span><span class="p">).</span>
<span class="nf">father_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">father_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">charles</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
<span class="nf">grandparent_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">grandparent_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
</pre></div>
<p>The satisfiability semantics also has an alternative, more mathematical characterisation as the <a href="/wiki/Least_fixed_point" title="Least fixed point">least fixed point</a> of the function that uses the rules in the program to derive new facts from existing facts in one step of inference.
</p><p>Remarkably, the same problem-solving methods of forward and backward reasoning, which were originally developed for the logical consequence semantics, are equally applicable to the satisfiability semantics: Forward reasoning generates the minimal model of a Horn clause program, by deriving new facts from existing facts, until no new additional facts can be generated. Backward reasoning, which succeeds by reducing a goal to subgoals, until all subgoals are solved by facts, ensures that the goal is true in the minimal model, without generating the model explicitly.<sup id="cite_ref-34" class="reference"><a href="#cite_note-34"><span class="cite-bracket">&#91;</span>34<span class="cite-bracket">&#93;</span></a></sup>
</p><p>The difference between the two declarative semantics can be seen with the definitions of addition and multiplication in <a href="/wiki/Peano_arithmetic#Defining_arithmetic_operations_and_relations" class="mw-redirect" title="Peano arithmetic">successor arithmetic</a>, which represents the natural numbers <code>0, 1, 2, ...</code> as a sequence of terms of the form <code>0, s(0), s(s(0)), ...</code>. In general, the term <code>s(X)</code> represents the successor of <code>X,</code> namely <code>X + 1.</code> Here are the standard definitions of addition and multiplication in functional notation:
</p>
<pre>     X + 0 = X.
     X + s(Y)    = s(X + Y). 
i.e. X + (Y + 1) = (X + Y) + 1

     X × 0 = 0.
     X × s(Y)    = X + (X × Y). 
i.e. X × (Y + 1) = X + (X × Y).
</pre>
<p>Here are the same definitions as a logic program, using <code>add(X, Y, Z)</code> to represent <code>X + Y = Z,</code> and <code>multiply(X, Y, Z)</code> to represent <code>X × Y = Z</code>:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">add</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
<span class="nf">add</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nf">s</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="nf">s</span><span class="p">(</span><span class="nv">Z</span><span class="p">))</span> <span class="p">:-</span> <span class="nf">add</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">).</span>

<span class="nf">multiply</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">multiply</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nf">s</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="nv">W</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">multiply</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">add</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">,</span> <span class="nv">W</span><span class="p">).</span>
</pre></div>
<p>The two declarative semantics both give the same answers for the same existentially quantified conjunctions of addition and multiplication goals. For example <code>2 × 2 = X</code> has the solution <code>X = 4</code>; and <code>X × X = X + X</code> has two solutions <code>X = 0</code> and <code>X = 2</code>:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">multiply</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="nv">X</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)))).</span>

<span class="s s-Atom">?-</span> <span class="nf">multiply</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nf">add</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nv">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Y</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="nv">X</span> <span class="o">=</span> <span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="nv">Y</span> <span class="o">=</span> <span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)))).</span>
</pre></div>
<p>However, with the logical-consequence semantics, there are non-standard models of the program, in which, for example, <code>add(s(s(0)), s(s(0)), s(s(s(s(s(0)))))),</code> i.e. <code>2 + 2 = 5</code> is true. But with the satisfiability semantics, there is only one model, namely the standard model of arithmetic, in which <code>2 + 2 = 5</code> is false.
</p><p>In both semantics, the goal <code class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><span class="s s-Atom">?-</span> <span class="nf">add</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="nf">s</span><span class="p">(</span><span class="mi">0</span><span class="p">))))))</span></code> fails. In the satisfiability semantics, the failure of the goal means that the truth value of the goal is false. But in the logical consequence semantics, the failure means that the truth value of the goal is unknown.
</p>
<div class="mw-heading mw-heading3"><h3 id="Negation_as_failure">Negation as failure</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=7" title="Edit section: Negation as failure"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Negation_as_failure" title="Negation as failure">Negation as failure</a></div>
<p><a href="/wiki/Negation_as_failure" title="Negation as failure">Negation as failure</a> (NAF), as a way of concluding that a negative condition <code>not p</code> holds by showing that the positive condition <code>p</code> fails to hold, was already a feature of early Prolog systems. The resulting extension of <a href="/wiki/SLD_resolution" title="SLD resolution">SLD resolution</a> is called <a href="/wiki/SLD_resolution#SLDNF" title="SLD resolution">SLDNF</a>. A similar construct, called "thnot", also existed in <a href="/wiki/Micro-Planner_(programming_language)" class="mw-redirect" title="Micro-Planner (programming language)">Micro-Planner</a>.
</p><p>The logical semantics of NAF was unresolved until <a href="/wiki/Keith_Clark_(computer_scientist)" title="Keith Clark (computer scientist)">Keith Clark</a><sup id="cite_ref-35" class="reference"><a href="#cite_note-35"><span class="cite-bracket">&#91;</span>35<span class="cite-bracket">&#93;</span></a></sup> showed that, under certain natural conditions, NAF is an efficient, correct (and sometimes complete) way of reasoning with the logical consequence semantics using the <a href="/wiki/Negation_as_failure#Completion_semantics" title="Negation as failure"><i>completion</i></a> of a logic program in first-order logic.
</p><p>Completion amounts roughly to regarding the set of all the program clauses with the same predicate in the head, say:
</p>
<dl><dd><code>A&#160;:-  Body<sub>1</sub>.</code></dd>
<dd><code>      ...</code></dd>
<dd><code>A&#160;:-  Body<sub>k</sub>.</code></dd></dl>
<p>as a definition of the predicate:
</p>
<dl><dd><code>A iff (Body<sub>1</sub> or ... or Body<sub>k</sub>)</code></dd></dl>
<p>where <code>iff</code> means "if and only if". The completion also includes axioms of equality, which correspond to <a href="/wiki/Unification_(computer_science)" title="Unification (computer science)">unification</a>. Clark showed that proofs generated by SLDNF are structurally similar to proofs generated by a natural deduction style of reasoning with the completion of the program.
</p><p>Consider, for example, the following program:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">punishment</span><span class="p">)</span> <span class="p">:-</span> 
    <span class="nf">is_a_thief</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">rehabilitation</span><span class="p">).</span>
    
<span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">rehabilitation</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">is_a_thief</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
    <span class="nf">is_a_minor</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">is_violent</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
    
<span class="nf">is_a_thief</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">).</span>
</pre></div>
<p>Given the goal of determining whether tom should receive a sanction, the first rule succeeds in showing that tom should be punished:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">should_receive_sanction</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">,</span> <span class="nv">Sanction</span><span class="p">).</span>
<span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">punishment</span><span class="p">.</span>
</pre></div>
<p>This is because tom is a thief, and it cannot be shown that tom should be rehabilitated. It cannot be shown that tom should be rehabilitated, because it cannot be shown that tom is a minor.
</p><p>If, however, we receive new information that tom is indeed a minor, the previous conclusion that tom should be punished is replaced by the new conclusion that tom should be rehabilitated:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">minor</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">).</span>

<span class="s s-Atom">?-</span> <span class="nf">should_receive_sanction</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">,</span> <span class="nv">Sanction</span><span class="p">).</span>
<span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">rehabilitation</span><span class="p">.</span>
</pre></div>
<p>This property of withdrawing a conclusion when new information is added, is called non-monotonicity, and it makes logic programming a <a href="/wiki/Non-monotonic_logic" title="Non-monotonic logic">non-monotonic logic</a>.
</p><p>But, if we are now told that tom is violent, the conclusion that tom should be punished will be reinstated:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">violent</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">).</span>

<span class="s s-Atom">?-</span> <span class="nf">should_receive_sanction</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">,</span> <span class="nv">Sanction</span><span class="p">).</span>
<span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">punishment</span><span class="p">.</span>
</pre></div>
<p>The completion of this program is:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Sanction</span><span class="p">)</span> <span class="s s-Atom">iff</span> 
    <span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">punishment</span><span class="p">,</span> <span class="nf">is_a_thief</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> 
    <span class="o">not</span> <span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">rehabilitation</span><span class="p">)</span>
 <span class="s s-Atom">or</span> <span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">rehabilitation</span><span class="p">,</span> <span class="nf">is_a_thief</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">is_a_minor</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
    <span class="o">not</span> <span class="nf">is_violent</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
    
<span class="nf">is_a_thief</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">iff</span> <span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">tom</span><span class="p">.</span>
<span class="nf">is_a_minor</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">iff</span> <span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">tom</span><span class="p">.</span>
<span class="nf">is_violent</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">iff</span> <span class="nv">X</span> <span class="o">=</span> <span class="s s-Atom">tom</span><span class="p">.</span>
</pre></div>
<p>The notion of completion is closely related to <a href="/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy's</a> <a href="/wiki/Circumscription_(logic)" title="Circumscription (logic)">circumscription</a> semantics for default reasoning,<sup id="cite_ref-36" class="reference"><a href="#cite_note-36"><span class="cite-bracket">&#91;</span>36<span class="cite-bracket">&#93;</span></a></sup> and to <a href="/wiki/Raymond_Reiter" title="Raymond Reiter">Ray Reiter's</a> <a href="/wiki/Closed_world_assumption" class="mw-redirect" title="Closed world assumption">closed world assumption</a>.<sup id="cite_ref-37" class="reference"><a href="#cite_note-37"><span class="cite-bracket">&#91;</span>37<span class="cite-bracket">&#93;</span></a></sup>
</p><p>The completion semantics for negation is a logical consequence semantics, for which SLDNF provides a proof-theoretic implementation. However, in the 1980s, the satisfiability semantics became more popular for logic programs with negation. In the satisfiability semantics, negation is interpreted according to the classical definition of truth in an intended or standard model of the logic program.
</p><p>In the case of logic programs with negative conditions, there are two main variants of the satisfiability semantics: In the <a href="/wiki/Well-founded_semantics" title="Well-founded semantics">well-founded semantics</a>, the intended model of a logic program is a unique, three-valued, minimal model, which always exists. The well-founded semantics generalises the notion of <a href="/wiki/Inductive_definition" class="mw-redirect" title="Inductive definition">inductive definition</a> in mathematical logic.<sup id="cite_ref-38" class="reference"><a href="#cite_note-38"><span class="cite-bracket">&#91;</span>38<span class="cite-bracket">&#93;</span></a></sup> <a href="/wiki/XSB" title="XSB">XSB Prolog</a><sup id="cite_ref-39" class="reference"><a href="#cite_note-39"><span class="cite-bracket">&#91;</span>39<span class="cite-bracket">&#93;</span></a></sup> implements the well-founded semantics using SLG resolution.<sup id="cite_ref-40" class="reference"><a href="#cite_note-40"><span class="cite-bracket">&#91;</span>40<span class="cite-bracket">&#93;</span></a></sup>
</p><p>In the alternative <a href="/wiki/Stable_model_semantics" title="Stable model semantics">stable model semantics</a>, there may be no intended models or several intended models, all of which are minimal and two-valued. The stable model semantics underpins <a href="/wiki/Answer_set_programming" title="Answer set programming">answer set programming</a> (ASP).
</p><p>Both the well-founded and stable model semantics apply to arbitrary logic programs with negation. However, both semantics coincide for <a href="/wiki/Syntax_and_semantics_of_logic_programming#Stratified_negation" title="Syntax and semantics of logic programming">stratified</a> logic programs. For example, the program for sanctioning thieves is (locally) stratified, and all three semantics for the program determine the same intended model:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">should_receive_sanction</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">,</span> <span class="s s-Atom">punishment</span><span class="p">).</span>
<span class="nf">is_a_thief</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">).</span>
<span class="nf">is_a_minor</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">).</span>
<span class="nf">is_violent</span><span class="p">(</span><span class="s s-Atom">tom</span><span class="p">).</span>
</pre></div>
<p>Attempts to understand negation in logic programming have also contributed to the development of <a href="/wiki/Argumentation_framework" title="Argumentation framework">abstract argumentation frameworks</a>.<sup id="cite_ref-41" class="reference"><a href="#cite_note-41"><span class="cite-bracket">&#91;</span>41<span class="cite-bracket">&#93;</span></a></sup> In an argumentation interpretation of negation, the initial argument that tom should be punished because he is a thief, is attacked by the argument that he should be rehabilitated because he is a minor. But the fact that tom is violent undermines the argument that tom should be rehabilitated and reinstates the argument that tom should be punished.
</p>
<div class="mw-heading mw-heading3"><h3 id="Metalogic_programming">Metalogic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=8" title="Edit section: Metalogic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p><a href="/wiki/Metaprogramming" title="Metaprogramming">Metaprogramming</a>, in which programs are treated as data, was already a feature of early Prolog implementations.<sup id="cite_ref-42" class="reference"><a href="#cite_note-42"><span class="cite-bracket">&#91;</span>42<span class="cite-bracket">&#93;</span></a></sup><sup id="cite_ref-Warren_43-0" class="reference"><a href="#cite_note-Warren-43"><span class="cite-bracket">&#91;</span>43<span class="cite-bracket">&#93;</span></a></sup> For example, the Edinburgh DEC10 implementation of Prolog included "an interpreter and a compiler, both written in Prolog itself".<sup id="cite_ref-Warren_43-1" class="reference"><a href="#cite_note-Warren-43"><span class="cite-bracket">&#91;</span>43<span class="cite-bracket">&#93;</span></a></sup> The simplest metaprogram is the so-called "<a href="/wiki/Vanilla_(computing)" class="mw-redirect" title="Vanilla (computing)">vanilla</a>" meta-interpreter:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span>    <span class="nf">solve</span><span class="p">(</span><span class="s s-Atom">true</span><span class="p">).</span>
    <span class="nf">solve</span><span class="p">((</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">)):-</span> <span class="nf">solve</span><span class="p">(</span><span class="nv">B</span><span class="p">),</span><span class="nf">solve</span><span class="p">(</span><span class="nv">C</span><span class="p">).</span>
    <span class="nf">solve</span><span class="p">(</span><span class="nv">A</span><span class="p">):-</span> <span class="nf">clause</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nf">solve</span><span class="p">(</span><span class="nv">B</span><span class="p">).</span>
</pre></div>
<p>where true represents an empty conjunction, and (B,C) is a composite term representing the conjunction of B and C. The predicate clause(A,B) means that there is a clause of the form	A&#160;:- B.
</p><p>Metaprogramming is an application of the more general use of a <i><a href="/wiki/Metalogic" title="Metalogic">metalogic</a></i> or <i><a href="/wiki/Metalanguage" title="Metalanguage">metalanguage</a></i>  to describe and reason about another language, called the <i>object language</i>.
</p><p>Metalogic programming allows object-level and metalevel representations to be combined, as in natural language. For example, in the following program, the atomic formula <code>attends(Person, Meeting)</code> occurs both as an object-level formula, and as an argument of the metapredicates <code>prohibited</code> and <code>approved.</code>
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">prohibited</span><span class="p">(</span><span class="nf">attends</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="nv">Meeting</span><span class="p">))</span> <span class="p">:-</span> 
    <span class="o">not</span><span class="p">(</span><span class="nf">approved</span><span class="p">(</span><span class="nf">attends</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="nv">Meeting</span><span class="p">))).</span>

<span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="s s-Atom">scolding</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">attends</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="nv">Meeting</span><span class="p">),</span> 
    <span class="nf">lofty</span><span class="p">(</span><span class="nv">Person</span><span class="p">),</span> <span class="nf">prohibited</span><span class="p">(</span><span class="nf">attends</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="nv">Meeting</span><span class="p">)).</span>
<span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="s s-Atom">banishment</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">attends</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="nv">Meeting</span><span class="p">),</span> 
    <span class="nf">lowly</span><span class="p">(</span><span class="nv">Person</span><span class="p">),</span> <span class="nf">prohibited</span><span class="p">(</span><span class="nf">attends</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="nv">Meeting</span><span class="p">)).</span>

<span class="nf">approved</span><span class="p">(</span><span class="nf">attends</span><span class="p">(</span><span class="s s-Atom">alice</span><span class="p">,</span> <span class="s s-Atom">tea_party</span><span class="p">)).</span>
<span class="nf">attends</span><span class="p">(</span><span class="s s-Atom">mad_hatter</span><span class="p">,</span> <span class="s s-Atom">tea_party</span><span class="p">).</span>
<span class="nf">attends</span><span class="p">(</span><span class="s s-Atom">dormouse</span><span class="p">,</span> <span class="s s-Atom">tea_party</span><span class="p">).</span>

<span class="nf">lofty</span><span class="p">(</span><span class="s s-Atom">mad_hatter</span><span class="p">).</span>
<span class="nf">lowly</span><span class="p">(</span><span class="s s-Atom">dormouse</span><span class="p">).</span>

<span class="s s-Atom">?-</span> <span class="nf">should_receive_sanction</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">).</span>
<span class="nv">Person</span> <span class="o">=</span> <span class="s s-Atom">mad_hatter</span><span class="p">,</span>
<span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">scolding</span><span class="p">.</span>
<span class="nv">Person</span> <span class="o">=</span> <span class="s s-Atom">dormouse</span><span class="p">,</span>
<span class="nv">Sanction</span> <span class="o">=</span> <span class="s s-Atom">banishment</span><span class="p">.</span>
</pre></div>
<div class="mw-heading mw-heading3"><h3 id="Relationship_with_the_Computational-representational_understanding_of_mind">Relationship with the <a href="/wiki/Computational-representational_understanding_of_mind" title="Computational-representational understanding of mind">Computational-representational understanding of mind</a></h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=9" title="Edit section: Relationship with the Computational-representational understanding of mind"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>In his popular Introduction to Cognitive Science,<sup id="cite_ref-44" class="reference"><a href="#cite_note-44"><span class="cite-bracket">&#91;</span>44<span class="cite-bracket">&#93;</span></a></sup> <a href="/wiki/Paul_Thagard" title="Paul Thagard">Paul Thagard</a> includes logic and <a href="/wiki/Rule-based_system" title="Rule-based system">rules</a> as alternative approaches to modelling human thinking. He argues that rules, which have the form <i>IF condition THEN action</i>, are "very similar" to logical conditionals, but they are simpler and have greater psychological plausability (page 51). Among other differences between logic and rules, he argues that logic uses deduction, but rules use search (page 45) and can be used to reason either forward or backward (page 47). Sentences in logic "have to be interpreted as <i>universally true</i>", but rules can be <i>defaults</i>, which admit exceptions (page 44).
</p><p>He states that "unlike logic, rule-based systems can also easily represent strategic information
about what to do" (page 45). For example, "IF you want to go home for the weekend, and you have bus fare, THEN
you can catch a bus". He does not observe that the same strategy of reducing a goal to subgoals can be interpreted, in the manner of logic programming, as applying backward reasoning to a logical conditional:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">can_go</span><span class="p">(</span><span class="s s-Atom">you</span><span class="p">,</span> <span class="s s-Atom">home</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">have</span><span class="p">(</span><span class="s s-Atom">you</span><span class="p">,</span> <span class="s s-Atom">bus_fare</span><span class="p">),</span> <span class="nf">catch</span><span class="p">(</span><span class="s s-Atom">you</span><span class="p">,</span> <span class="s s-Atom">bus</span><span class="p">).</span>
</pre></div>
<p>All of these characteristics of rule-based systems - search, forward and backward reasoning, default reasoning, and goal-reduction - are also defining characteristics of logic programming. This suggests that Thagard's conclusion (page 56) that:
</p>
<blockquote>
<p>Much of human knowledge is naturally described in terms of rules, and many kinds of thinking such as planning can be modeled by rule-based systems.
</p>
</blockquote>
<p>also applies to logic programming.
</p><p>Other arguments showing how logic programming can be used to model aspects of human thinking are presented by <a href="/wiki/Keith_Stenning" title="Keith Stenning">Keith Stenning</a> and <a href="/wiki/Michiel_van_Lambalgen" title="Michiel van Lambalgen">Michiel van Lambalgen</a> in their book,
Human Reasoning and Cognitive Science.<sup id="cite_ref-45" class="reference"><a href="#cite_note-45"><span class="cite-bracket">&#91;</span>45<span class="cite-bracket">&#93;</span></a></sup> They show how the non-monotonic character of logic programs can be used to explain human performance on a variety of psychological tasks. They also show (page 237) that  "closed–world reasoning in its guise as logic programming has an appealing neural implementation, unlike classical logic."
</p><p>In The Proper Treatment of Events,<sup id="cite_ref-46" class="reference"><a href="#cite_note-46"><span class="cite-bracket">&#91;</span>46<span class="cite-bracket">&#93;</span></a></sup>
Michiel van Lambalgen and Fritz Hamm investigate the use of constraint logic programming to code "temporal notions in natural language by looking at the way human beings construct time".
</p>
<div class="mw-heading mw-heading3"><h3 id="Knowledge_representation">Knowledge representation</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=10" title="Edit section: Knowledge representation"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>The use of logic to represent procedural knowledge and strategic information was one of the main goals contributing to the early development of logic programming. Moreover, it continues to be an important feature of the Prolog family of logic programming languages today. However, many applications of logic programming, including Prolog applications, increasingly focus on the use of logic to represent purely declarative knowledge. These applications include both the representation of general <a href="/wiki/Commonsense_reasoning" title="Commonsense reasoning">commonsense</a> knowledge and the representation of domain specific <a href="/wiki/Expert_system" title="Expert system">expertise</a>.
</p><p>Commonsense includes knowledge about cause and effect, as formalised, for example, in the <a href="/wiki/Situation_calculus" title="Situation calculus">situation calculus</a>, <a href="/wiki/Event_calculus" title="Event calculus">event calculus</a> and <a href="/wiki/Action_language" title="Action language">action languages</a>. Here is a simplified example, which illustrates the main features of such formalisms. The first clause states that a fact holds immediately after an event initiates (or causes) the fact. The second clause is a <i><a href="/wiki/Frame_problem" title="Frame problem">frame axiom</a></i>, which states that a fact that holds at a time continues to hold at the next time unless it is terminated by an event that happens at the time. This formulation allows more than one event to occur at the same time:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time2</span><span class="p">)</span> <span class="p">:-</span> 
    <span class="nf">happens</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">),</span>
    <span class="nv">Time2</span> <span class="o">is</span> <span class="nv">Time1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nf">initiates</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Fact</span><span class="p">).</span>
     
<span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time2</span><span class="p">)</span> <span class="p">:-</span> 
	<span class="nf">happens</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">),</span>
    <span class="nv">Time2</span> <span class="o">is</span> <span class="nv">Time1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">),</span>
    <span class="o">not</span><span class="p">(</span><span class="nf">terminated</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">)).</span>

<span class="nf">terminated</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time</span><span class="p">)</span> <span class="p">:-</span>
   <span class="nf">happens</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Time</span><span class="p">),</span>
   <span class="nf">terminates</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Fact</span><span class="p">).</span>
</pre></div>
<p>Here <code>holds</code> is a meta-predicate, similar to <code>solve</code> above. However, whereas <code>solve</code> has only one argument, which applies to general clauses, the first argument of <code>holds</code> is a fact and the second argument is a time (or state). The atomic formula <code>holds(Fact, Time)</code> expresses that the <code>Fact</code> holds at the <code>Time</code>. Such time-varying facts are also called <a href="/wiki/Fluent_(artificial_intelligence)" title="Fluent (artificial intelligence)">fluents</a>. The atomic formula <code>happens(Event, Time)</code> expresses that the Event happens at the <code>Time</code>.
</p><p>The following example illustrates how these clauses can be used to reason about causality in a  toy <a href="/wiki/Blocks_world" title="Blocks world">blocks world</a>. Here, in the initial state at time 0, a green block is on a table and a red block is stacked on the green block (like a traffic light). At time 0, the red block is moved to the table. At time 1, the green block is moved onto the red block. Moving an object onto a place terminates the fact that the object is on any place, and initiates the fact that the object is on the place to which it is moved:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">holds</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">holds</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">green_block</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>

<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">red_block</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span>

<span class="nf">initiates</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place</span><span class="p">),</span> <span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place</span><span class="p">)).</span>
<span class="nf">terminates</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place2</span><span class="p">),</span> <span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place1</span><span class="p">)).</span>

<span class="s s-Atom">?-</span> <span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time</span><span class="p">).</span>

<span class="nv">Fact</span> <span class="o">=</span> <span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span><span class="s s-Atom">table</span><span class="p">),</span>
<span class="nv">Time</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="nv">Fact</span> <span class="o">=</span> <span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span><span class="s s-Atom">green_block</span><span class="p">),</span>
<span class="nv">Time</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="nv">Fact</span> <span class="o">=</span> <span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span><span class="s s-Atom">table</span><span class="p">),</span>
<span class="nv">Time</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="nv">Fact</span> <span class="o">=</span> <span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span><span class="s s-Atom">table</span><span class="p">),</span>
<span class="nv">Time</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="nv">Fact</span> <span class="o">=</span> <span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span><span class="s s-Atom">red_block</span><span class="p">),</span>
<span class="nv">Time</span> <span class="o">=</span> <span class="mf">2.</span>
<span class="nv">Fact</span> <span class="o">=</span> <span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span><span class="s s-Atom">table</span><span class="p">),</span>
<span class="nv">Time</span> <span class="o">=</span> <span class="mf">2.</span>
</pre></div>
<p>Forward reasoning and backward reasoning generate the same answers to the goal <code>holds(Fact, Time)</code>. But forward reasoning generates fluents <i>progressively</i> in temporal order, and backward reasoning generates fluents <i>regressively</i>, as in the domain-specific use of <a href="/wiki/Situation_calculus#Regression" title="Situation calculus">regression</a> in the <a href="/wiki/Situation_calculus" title="Situation calculus">situation calculus</a>.<sup id="cite_ref-47" class="reference"><a href="#cite_note-47"><span class="cite-bracket">&#91;</span>47<span class="cite-bracket">&#93;</span></a></sup>
</p><p>Logic programming has also proved to be useful for representing domain-specific expertise in <a href="/wiki/Expert_system" title="Expert system">expert systems</a>.<sup id="cite_ref-48" class="reference"><a href="#cite_note-48"><span class="cite-bracket">&#91;</span>48<span class="cite-bracket">&#93;</span></a></sup> But human expertise, like general-purpose commonsense, is mostly implicit and <a href="/wiki/Tacit_knowledge" title="Tacit knowledge">tacit</a>, and it is often difficult to represent such implicit knowledge in explicit rules. This difficulty does not arise, however, when logic programs are used to represent the existing, explicit rules of a business organisation or legal authority.
</p><p>For example, here is a representation of a simplified version of the first sentence of the British Nationality Act, which states that a person who is born in the UK becomes a British citizen at the time of birth if a parent of the person is a British citizen at the time of birth:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">initiates</span><span class="p">(</span><span class="nf">birth</span><span class="p">(</span><span class="nv">Person</span><span class="p">),</span> <span class="nf">citizen</span><span class="p">(</span><span class="nv">Person</span><span class="p">,</span> <span class="s s-Atom">uk</span><span class="p">)):-</span>
    <span class="nf">time_of</span><span class="p">(</span><span class="nf">birth</span><span class="p">(</span><span class="nv">Person</span><span class="p">),</span> <span class="nv">Time</span><span class="p">),</span>
    <span class="nf">place_of</span><span class="p">(</span><span class="nf">birth</span><span class="p">(</span><span class="nv">Person</span><span class="p">),</span> <span class="s s-Atom">uk</span><span class="p">),</span>
    <span class="nf">parent_child</span><span class="p">(</span><span class="nv">Another_Person</span><span class="p">,</span> <span class="nv">Person</span><span class="p">),</span>
    <span class="nf">holds</span><span class="p">(</span><span class="nf">citizen</span><span class="p">(</span><span class="nv">Another_Person</span><span class="p">,</span> <span class="s s-Atom">uk</span><span class="p">),</span> <span class="nv">Time</span><span class="p">).</span>
</pre></div>
<p>Historically, the representation of a large portion of the British Nationality Act as a logic program in the 1980s<sup id="cite_ref-49" class="reference"><a href="#cite_note-49"><span class="cite-bracket">&#91;</span>49<span class="cite-bracket">&#93;</span></a></sup> was "hugely influential for the development of computational representations of legislation, showing how logic programming enables intuitively appealing representations that can be directly deployed to generate automatic inferences".<sup id="cite_ref-50" class="reference"><a href="#cite_note-50"><span class="cite-bracket">&#91;</span>50<span class="cite-bracket">&#93;</span></a></sup>
</p><p>More recently, the PROLEG system,<sup id="cite_ref-51" class="reference"><a href="#cite_note-51"><span class="cite-bracket">&#91;</span>51<span class="cite-bracket">&#93;</span></a></sup> initiated in 2009 and consisting of approximately 2500 rules and exceptions of civil code and supreme court case rules in Japan, has become possibly the largest legal rule base in the world.<sup id="cite_ref-:02_52-0" class="reference"><a href="#cite_note-:02-52"><span class="cite-bracket">&#91;</span>52<span class="cite-bracket">&#93;</span></a></sup>
</p>
<div class="mw-heading mw-heading2"><h2 id="Variants_and_extensions">Variants and extensions</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=11" title="Edit section: Variants and extensions"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<div class="mw-heading mw-heading3"><h3 id="Prolog">Prolog</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=12" title="Edit section: Prolog"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Prolog" title="Prolog">Prolog</a></div>
<p>The SLD resolution rule of inference is neutral about the order in which subgoals in the bodies of clauses can be <i>selected</i> for solution. For the sake of efficiency, Prolog restricts this order to the order in which the subgoals are written. SLD is also neutral about the strategy for searching the space of SLD proofs.
Prolog searches this space, top-down,  depth-first, trying different clauses for solving the same (sub)goal in the order in which the clauses are written.
</p><p>This search strategy has the advantage that the current branch of the tree can be represented efficiently by a <a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">stack</a>. When a goal clause at the top of the stack is reduced to a new goal clause, the new goal clause is pushed onto the top of the stack. When the selected subgoal in the goal clause at the top of the stack cannot be solved, the search strategy <i><a href="/wiki/Backtracking" title="Backtracking">backtracks</a></i>, removing the goal clause from the top of the stack, and retrying the attempted solution of the selected subgoal in the previous goal clause using the next clause that matches the selected subgoal.
</p><p>Backtracking can be restricted by using a subgoal, called <i><a href="/wiki/Cut_(logic_programming)" title="Cut (logic programming)">cut</a></i>, written as&#160;!, which always succeeds but cannot be backtracked. Cut can be used to improve efficiency, but can also interfere with the logical meaning of clauses. In many cases, the use of cut can be replaced by negation as failure. In fact, negation as failure can be defined in Prolog, by using cut, together with any literal, say <i>fail</i>, that unifies with the head of no clause:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="o">not</span><span class="p">(</span><span class="nv">P</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">P</span><span class="p">,</span> <span class="p">!,</span> <span class="s s-Atom">fail</span><span class="p">.</span>
<span class="o">not</span><span class="p">(</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
<p>Prolog provides other features, in addition to cut, that do not have a logical interpretation. These include the built-in predicates <i>assert</i> and <i>retract</i> for destructively updating the state of the program during program execution.
</p><p>For example, the <a href="#Knowledge_representation">toy blocks world example above</a> can be implemented without frame axioms using destructive change of state:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">).</span>
<span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">green_block</span><span class="p">).</span>

<span class="nf">move</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place2</span><span class="p">)</span> <span class="p">:-</span> 
	<span class="nf">retract</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place1</span><span class="p">)),</span> 
	<span class="nf">assert</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place2</span><span class="p">).</span>
</pre></div>
<p>The sequence of move events and the resulting locations of the blocks can be computed by executing the query:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">move</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="nf">move</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">red_block</span><span class="p">),</span> <span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place</span><span class="p">).</span>

<span class="nv">Object</span> <span class="o">=</span> <span class="s s-Atom">red_block</span><span class="p">,</span>
<span class="nv">Place</span> <span class="o">=</span> <span class="s s-Atom">table</span><span class="p">.</span>
<span class="nv">Object</span> <span class="o">=</span> <span class="s s-Atom">green_block</span><span class="p">,</span>
<span class="nv">Place</span> <span class="o">=</span> <span class="s s-Atom">red_block</span><span class="p">.</span>
</pre></div>
<p>Various extensions of logic programming have been developed to provide a logical framework for such destructive change of state.<sup id="cite_ref-TL_53-0" class="reference"><a href="#cite_note-TL-53"><span class="cite-bracket">&#91;</span>53<span class="cite-bracket">&#93;</span></a></sup><sup id="cite_ref-54" class="reference"><a href="#cite_note-54"><span class="cite-bracket">&#91;</span>54<span class="cite-bracket">&#93;</span></a></sup><sup id="cite_ref-55" class="reference"><a href="#cite_note-55"><span class="cite-bracket">&#91;</span>55<span class="cite-bracket">&#93;</span></a></sup>
</p><p>The broad range of Prolog applications, both in isolation and in combination with other languages is highlighted in the Year of Prolog Book,<sup id="cite_ref-Prolog_Book_21-1" class="reference"><a href="#cite_note-Prolog_Book-21"><span class="cite-bracket">&#91;</span>21<span class="cite-bracket">&#93;</span></a></sup> celebrating the 50 year anniversary of Prolog in 2022.
</p><p>Prolog has also contributed to the development of other programming languages, including <a href="/wiki/Algebraic_Logic_Functional_programming_language" title="Algebraic Logic Functional programming language">ALF</a>, <a href="/wiki/Fril" title="Fril">Fril</a>, <a href="/wiki/G%C3%B6del_(programming_language)" title="Gödel (programming language)">Gödel</a>, <a href="/wiki/Mercury_programming_language" class="mw-redirect" title="Mercury programming language">Mercury</a>, <a href="/wiki/Oz_(programming_language)" title="Oz (programming language)">Oz</a>, <a href="/wiki/Ciao_(programming_language)" title="Ciao (programming language)">Ciao</a>, <a href="/wiki/Visual_Prolog" title="Visual Prolog">Visual Prolog</a>, <a href="/wiki/XSB" title="XSB">XSB</a>, and <a href="/wiki/%CE%9BProlog" title="ΛProlog">λProlog</a>.
</p>
<div class="mw-heading mw-heading3"><h3 id="Constraint_logic_programming">Constraint logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=13" title="Edit section: Constraint logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic programming</a></div>
<p><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic programming</a> (CLP) combines Horn clause logic programming with <a href="/wiki/Constraint_solving" class="mw-redirect" title="Constraint solving">constraint solving</a>. It extends Horn clauses by allowing some predicates, declared as constraint predicates, to occur as literals in the body of a clause. Constraint predicates are not defined by the facts and rules in the program, but are predefined by some domain-specific model-theoretic structure or theory.
</p><p>Procedurally, subgoals whose predicates are defined by the program are solved by goal-reduction, as in ordinary logic programming, but constraints are simplified and checked for satisfiability by a domain-specific constraint-solver, which implements the semantics of the constraint predicates. An initial problem is solved by reducing it to a satisfiable conjunction of constraints.
</p><p>Interestingly, the first version of Prolog already included a constraint predicate dif(term1, term2), from Philippe Roussel's 1972 PhD thesis, which succeeds if both of its arguments are different terms, but which is delayed if either of the terms contains a variable.<sup id="cite_ref-:02_52-1" class="reference"><a href="#cite_note-:02-52"><span class="cite-bracket">&#91;</span>52<span class="cite-bracket">&#93;</span></a></sup>
</p><p>The following constraint logic program represents a toy temporal database of <code>john's</code> history as a teacher:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">teaches</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">hardware</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="p">:-</span> <span class="mi">1990</span> <span class="s s-Atom">≤</span> <span class="nv">T</span><span class="p">,</span> <span class="nv">T</span> <span class="o">&lt;</span> <span class="mf">1999.</span>
<span class="nf">teaches</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">software</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="p">:-</span> <span class="mi">1999</span> <span class="s s-Atom">≤</span> <span class="nv">T</span><span class="p">,</span> <span class="nv">T</span> <span class="o">&lt;</span> <span class="mf">2005.</span>
<span class="nf">teaches</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">logic</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="p">:-</span> <span class="mi">2005</span> <span class="s s-Atom">≤</span> <span class="nv">T</span><span class="p">,</span> <span class="nv">T</span> <span class="s s-Atom">≤</span> <span class="mf">2012.</span>
<span class="nf">rank</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">instructor</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="p">:-</span> <span class="mi">1990</span> <span class="s s-Atom">≤</span> <span class="nv">T</span><span class="p">,</span> <span class="nv">T</span> <span class="o">&lt;</span> <span class="mf">2010.</span>
<span class="nf">rank</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">professor</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="p">:-</span> <span class="mi">2010</span> <span class="s s-Atom">≤</span> <span class="nv">T</span><span class="p">,</span> <span class="nv">T</span> <span class="o">&lt;</span> <span class="mf">2014.</span>
</pre></div>
<p>Here <code>≤</code> and <code>&lt;</code> are constraint predicates, with their usual intended semantics. The following goal clause queries the database to find out when <code>john</code> both taught <code>logic</code> and was a <code>professor</code>:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">teaches</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">logic</span><span class="p">,</span> <span class="nv">T</span><span class="p">),</span> <span class="nf">rank</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">,</span> <span class="s s-Atom">professor</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
<p>The solution 
<code>
2010 ≤ T, T ≤ 2012
</code>
results from simplifying the constraints
<code>
2005 ≤ T, T ≤ 2012, 2010 ≤ T, T &lt; 2014.
</code>
</p><p>Constraint logic programming has been used to solve problems in such fields as <a href="/wiki/Civil_engineering" title="Civil engineering">civil engineering</a>, <a href="/wiki/Mechanical_engineering" title="Mechanical engineering">mechanical engineering</a>, <a href="/wiki/Digital_circuit" class="mw-redirect" title="Digital circuit">digital circuit</a> verification, <a href="/wiki/Automated_timetabling" class="mw-redirect" title="Automated timetabling">automated timetabling</a>, <a href="/wiki/Air_traffic_control" title="Air traffic control">air traffic control</a>, and finance. It is closely related to <a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">abductive logic programming</a>.
</p>
<div class="mw-heading mw-heading3"><h3 id="Datalog">Datalog</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=14" title="Edit section: Datalog"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Datalog" title="Datalog">Datalog</a></div>
<p>Datalog is a database definition language, which combines a relational view of data, as in <a href="/wiki/Relational_database" title="Relational database">relational databases</a>, with a logical view, as in logic programming.
</p><p>Relational databases use a relational calculus or relational algebra, with <a href="/wiki/Relational_database#Relational_operations" title="Relational database">relational operations</a>, such as <i>union</i>, <i>intersection</i>, <i>set difference</i> and <i>cartesian product</i> to specify queries, which access  a database. Datalog uses logical connectives, such as <i>or</i>, <i>and</i> and <i>not</i> in the bodies of rules to define relations as part of the database itself.
</p><p>It was recognized early in the development of relational databases that recursive queries cannot be expressed in either relational algebra or relational calculus, and that this defficiency can be remedied by introducing a least-fixed-point operator.<sup id="cite_ref-56" class="reference"><a href="#cite_note-56"><span class="cite-bracket">&#91;</span>56<span class="cite-bracket">&#93;</span></a></sup><sup id="cite_ref-57" class="reference"><a href="#cite_note-57"><span class="cite-bracket">&#91;</span>57<span class="cite-bracket">&#93;</span></a></sup> In contrast, recursive relations can be defined naturally by rules in logic programs, without the need for any new logical connectives or operators.
</p><p>Datalog differs from more general logic programming by having only constants and variables as terms. Moreover, all facts are variable-free, and rules are restricted, so that if they are executed bottom-up, then the derived facts are also variable-free.
</p><p>For example, consider the family database:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">mother_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">charles</span><span class="p">).</span>
<span class="nf">father_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">father_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">mother_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">father_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">parent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> 
     <span class="nf">ancestor_descendant</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> 
     <span class="nf">ancestor_descendant</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
<p>Bottom-up execution derives the following set of additional facts and terminates:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">parent_child</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">charles</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">parent_child</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>

<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">charles</span><span class="p">).</span>
<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="s s-Atom">charles</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>

<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">william</span><span class="p">).</span>
<span class="nf">ancestor_descendant</span><span class="p">(</span><span class="s s-Atom">elizabeth</span><span class="p">,</span> <span class="s s-Atom">harry</span><span class="p">).</span>
</pre></div>
<p>Top-down execution derives the same answers to the query:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">ancestor_descendant</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
<p>But then it goes into an infinite loop. However, top-down execution with <a href="/wiki/Tabled_logic_programming" title="Tabled logic programming">tabling</a> gives the same answers and terminates without looping.
</p>
<div class="mw-heading mw-heading3"><h3 id="Answer_set_programming">Answer set programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=15" title="Edit section: Answer set programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Answer_Set_Programming" class="mw-redirect" title="Answer Set Programming">Answer Set Programming</a></div>
<p>Like Datalog, Answer Set programming (ASP) is not Turing-complete. Moreover, instead of separating goals (or queries) from the program to be used in solving the goals, ASP  treats the whole program as a goal, and solves the goal by generating a stable model that makes the goal true. For this purpose, it uses the <a href="/wiki/Stable_model_semantics" title="Stable model semantics">stable model semantics</a>, according to which a logic program can have zero, one or more intended models. For example, the following program represents a degenerate variant of the map colouring problem of colouring two countries red or green:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span>
<span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span>
<span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span>
<span class="nf">colour</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">country</span><span class="p">(</span><span class="nv">C</span><span class="p">),</span> <span class="o">not</span><span class="p">(</span><span class="nf">colour</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">)).</span>
<span class="nf">colour</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">country</span><span class="p">(</span><span class="nv">C</span><span class="p">),</span> <span class="o">not</span><span class="p">(</span><span class="nf">colour</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">)).</span>
</pre></div>
<p>The problem has four solutions represented by four stable models:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span> <span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">).</span>   <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">).</span>

<span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span> <span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">).</span>

<span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span> <span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">).</span>   <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">).</span>

<span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span> <span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">).</span>
</pre></div>
<p>To represent the standard version of the map colouring problem, we need to add a constraint that two adjacent countries cannot be coloured the same colour. In ASP, this constraint can be written as a clause of the form:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="p">:-</span> <span class="nf">country</span><span class="p">(</span><span class="nv">C1</span><span class="p">),</span> <span class="nf">country</span><span class="p">(</span><span class="nv">C2</span><span class="p">),</span> <span class="nf">adjacent</span><span class="p">(</span><span class="nv">C1</span><span class="p">,</span> <span class="nv">C2</span><span class="p">),</span> <span class="nf">colour</span><span class="p">(</span><span class="nv">C1</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">colour</span><span class="p">(</span><span class="nv">C2</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</pre></div>
<p>With the addition of this constraint, the problem now has only two solutions:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span> <span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">).</span>   <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">).</span>

<span class="nf">country</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">).</span> <span class="nf">country</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">adjacent</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">iz</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">oz</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">).</span> <span class="nf">colour</span><span class="p">(</span><span class="s s-Atom">iz</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">).</span>
</pre></div>
<p>The addition of constraints of the form <code>:- Body.</code> eliminates models in which <code>Body</code> is true.
</p><p>Confusingly, <i>constraints in ASP</i> are different from <i>constraints in CLP</i>. Constraints in CLP are predicates that qualify answers to queries (and solutions of goals). Constraints in ASP are clauses that eliminate models that would otherwise satisfy goals. Constraints in ASP are like integrity constraints in databases.
</p><p>This combination of ordinary logic programming clauses and constraint clauses illustrates the generate-and-test methodology of problem solving in ASP: The ordinary clauses define a search space of possible solutions, and the constraints filter out unwanted solutions.<sup id="cite_ref-58" class="reference"><a href="#cite_note-58"><span class="cite-bracket">&#91;</span>58<span class="cite-bracket">&#93;</span></a></sup>
</p><p>Most implementations of ASP proceed in two steps: First they instantiate the program in all possible ways, reducing it to a propositional logic program (known as <i>grounding</i>). Then they apply a propositional logic problem solver, such as the <a href="/wiki/DPLL_algorithm" title="DPLL algorithm">DPLL algorithm</a> or a <a href="/wiki/Boolean_SAT_solver" class="mw-redirect" title="Boolean SAT solver">Boolean SAT solver</a>. However, some implementations, such as s(CASP)<sup id="cite_ref-59" class="reference"><a href="#cite_note-59"><span class="cite-bracket">&#91;</span>59<span class="cite-bracket">&#93;</span></a></sup> use a goal-directed, top-down, SLD resolution-like procedure without
grounding.
</p>
<div class="mw-heading mw-heading3"><h3 id="Abductive_logic_programming">Abductive logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=16" title="Edit section: Abductive logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic programming</a></div>
<p><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic programming</a><sup id="cite_ref-60" class="reference"><a href="#cite_note-60"><span class="cite-bracket">&#91;</span>60<span class="cite-bracket">&#93;</span></a></sup> (ALP), like CLP, extends normal logic programming by allowing the bodies of clauses to contain literals whose predicates are not defined by clauses. In ALP, these predicates are declared as <i>abducible</i> (or <i>assumable</i>), and are used as in <a href="/wiki/Abductive_reasoning#Formalizations_of_abduction#Logic-based_abduction" title="Abductive reasoning">abductive reasoning</a> to explain observations, or more generally to add new facts to the program (as assumptions) to solve goals.
</p><p>For example, suppose we are given an initial state in which a red block is on a green block on a table at time 0:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">holds</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">holds</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">green_block</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
</pre></div>
<p>Suppose we are also given the goal:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">holds</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span><span class="s s-Atom">red_block</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="nf">holds</span><span class="p">(</span><span class="nf">on</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span><span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">3</span><span class="p">).</span>
</pre></div>
<p>The goal can represent an observation, in which case a solution is an explanation of the observation. Or the goal can represent a desired future state of affairs, in which case a solution is a plan for achieving the goal.<sup id="cite_ref-61" class="reference"><a href="#cite_note-61"><span class="cite-bracket">&#91;</span>61<span class="cite-bracket">&#93;</span></a></sup>
</p><p>We can use the rules for cause and effect presented earlier to solve the goal, by treating the <code>happens</code> predicate as abducible:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time2</span><span class="p">)</span> <span class="p">:-</span> 
    <span class="nf">happens</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">),</span>
    <span class="nv">Time2</span> <span class="o">is</span> <span class="nv">Time1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nf">initiates</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Fact</span><span class="p">).</span>
     
<span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time2</span><span class="p">)</span> <span class="p">:-</span> 
	<span class="nf">happens</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">),</span>
    <span class="nv">Time2</span> <span class="o">is</span> <span class="nv">Time1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nf">holds</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">),</span>
    <span class="o">not</span><span class="p">(</span><span class="nf">terminated</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time1</span><span class="p">)).</span>
    
<span class="nf">terminated</span><span class="p">(</span><span class="nv">Fact</span><span class="p">,</span> <span class="nv">Time</span><span class="p">)</span> <span class="p">:-</span>
   <span class="nf">happens</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Time</span><span class="p">),</span>
   <span class="nf">terminates</span><span class="p">(</span><span class="nv">Event</span><span class="p">,</span> <span class="nv">Fact</span><span class="p">).</span>

<span class="nf">initiates</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place</span><span class="p">),</span> <span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place</span><span class="p">)).</span>
<span class="nf">terminates</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place2</span><span class="p">),</span> <span class="nf">on</span><span class="p">(</span><span class="nv">Object</span><span class="p">,</span> <span class="nv">Place1</span><span class="p">)).</span>
</pre></div>
<p>ALP solves the goal by reasoning backwards and adding assumptions to the program, to solve abducible subgoals. In this case there are many alternative solutions, including:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="s s-Atom">tick</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">red_block</span><span class="p">),</span> <span class="mi">2</span><span class="p">).</span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">happens</span><span class="p">(</span><span class="s s-Atom">tick</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">red_block</span><span class="p">),</span> <span class="mi">2</span><span class="p">).</span>
</pre></div>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">red_block</span><span class="p">),</span> <span class="mi">1</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="s s-Atom">tick</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span>
</pre></div>
<p>Here <code class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><span class="s s-Atom">tick</span></code> is an event that marks the passage of time without initiating or terminating any fluents.
</p><p>There are also solutions in which the two <code>move</code> events happen at the same time. For example:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">red_block</span><span class="p">,</span> <span class="s s-Atom">table</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="s s-Atom">green_block</span><span class="p">,</span> <span class="s s-Atom">red_block</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="s s-Atom">tick</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="nf">happens</span><span class="p">(</span><span class="s s-Atom">tick</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span>
</pre></div>
<p>Such solutions, if not desired, can be removed by adding an integrity constraint, which is like a constraint clause in ASP:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="p">:-</span> <span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="nv">Block1</span><span class="p">,</span> <span class="nv">Place</span><span class="p">),</span> <span class="nv">Time</span><span class="p">),</span> <span class="nf">happens</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="nv">Block2</span><span class="p">,</span> <span class="nv">Block1</span><span class="p">),</span> <span class="nv">Time</span><span class="p">).</span>
</pre></div>
<p>Abductive logic programming has been used for fault diagnosis, planning, natural language processing and machine learning. It has also been used to interpret negation as failure as a form of abductive reasoning.<sup id="cite_ref-62" class="reference"><a href="#cite_note-62"><span class="cite-bracket">&#91;</span>62<span class="cite-bracket">&#93;</span></a></sup>
</p>
<div class="mw-heading mw-heading3"><h3 id="Inductive_logic_programming">Inductive logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=17" title="Edit section: Inductive logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic programming</a></div>
<p>Inductive logic programming (ILP) is an approach to <a href="/wiki/Machine_learning" title="Machine learning">machine learning</a> that <a href="/wiki/Inductive_reasoning" title="Inductive reasoning">induces</a> logic programs as hypothetical generalisations of positive and negative examples. Given a logic program representing background knowledge and positive examples together with constraints representing negative examples, an ILP system induces a logic program that generalises the positive examples while excluding the negative examples.
</p><p>ILP is similar to ALP, in that both can be viewed as generating hypotheses to explain observations, and as employing constraints to exclude undesirable hypotheses. But in ALP the hypotheses are variable-free facts, and in ILP the hypotheses are general rules.<sup id="cite_ref-63" class="reference"><a href="#cite_note-63"><span class="cite-bracket">&#91;</span>63<span class="cite-bracket">&#93;</span></a></sup><sup id="cite_ref-64" class="reference"><a href="#cite_note-64"><span class="cite-bracket">&#91;</span>64<span class="cite-bracket">&#93;</span></a></sup>
</p><p>For example, given only background knowledge of the mother_child and father_child relations, and suitable examples of the grandparent_child relation, current ILP systems can generate the definition of grandparent_child, inventing an auxiliary predicate, which can be interpreted as the parent_child relation:<sup id="cite_ref-65" class="reference"><a href="#cite_note-65"><span class="cite-bracket">&#91;</span>65<span class="cite-bracket">&#93;</span></a></sup>
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">grandparent_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">):-</span> <span class="nf">auxiliary</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">auxiliary</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">auxiliary</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">):-</span> <span class="nf">mother_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">auxiliary</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">):-</span> <span class="nf">father_child</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
<p>Stuart Russell<sup id="cite_ref-66" class="reference"><a href="#cite_note-66"><span class="cite-bracket">&#91;</span>66<span class="cite-bracket">&#93;</span></a></sup> has referred to such invention of new concepts as the most important step needed for reaching human-level AI.
</p><p>Recent work in ILP, combining logic programming, learning and probability, has given rise to the fields of <a href="/wiki/Statistical_relational_learning" title="Statistical relational learning">statistical relational learning</a> and <a href="/wiki/Probabilistic_inductive_logic_programming" class="mw-redirect" title="Probabilistic inductive logic programming">probabilistic inductive logic programming</a>.
</p>
<div class="mw-heading mw-heading3"><h3 id="Concurrent_logic_programming">Concurrent logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=18" title="Edit section: Concurrent logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Concurrent_logic_programming" title="Concurrent logic programming">Concurrent logic programming</a></div>
<p>Concurrent logic programming integrates concepts of logic programming with <a href="/wiki/Concurrent_programming" class="mw-redirect" title="Concurrent programming">concurrent programming</a>. Its development was given a big impetus in the 1980s by its choice for the systems programming language of the <a href="/wiki/Fifth_generation_computer" class="mw-redirect" title="Fifth generation computer">Japanese Fifth Generation Project (FGCS)</a>.<sup id="cite_ref-67" class="reference"><a href="#cite_note-67"><span class="cite-bracket">&#91;</span>67<span class="cite-bracket">&#93;</span></a></sup>
</p><p>A concurrent logic program is a set of guarded <a href="/wiki/Horn_clauses" class="mw-redirect" title="Horn clauses">Horn clauses</a> of the form:
</p>
<dl><dd><dl><dd><code>H&#160;:- G<sub>1</sub>, ..., G<sub>n</sub> | B<sub>1</sub>, ..., B<sub>n</sub>.</code></dd></dl></dd></dl>
<p>The conjunction <code>G<sub>1</sub>, ... , G<sub>n</sub></code> is called the <a href="/wiki/Guard_(computer_science)" title="Guard (computer science)">guard</a> of the clause, and <span class="nounderlines" style="border: 1px solid var(--border-color-muted,#ddd); color: var(--color-base); background-color: var( --background-color-neutral-subtle, #fdfdfd); padding: 1px 1px;">|</span> is the commitment operator. Declaratively, guarded Horn clauses are read as ordinary logical implications:
</p>
<dl><dd><dl><dd><code>H if G<sub>1</sub> and ... and G<sub>n</sub> and B<sub>1</sub> and ... and B<sub>n</sub>.</code></dd></dl></dd></dl>
<p>However, procedurally, when there are several clauses whose heads <code>H</code> match a given goal, then all of the clauses are executed in parallel, checking whether their guards <code>G<sub>1</sub>, ... , G<sub>n</sub></code> hold. If the guards of more than one clause hold, then a committed choice is made to one of the clauses, and execution proceeds with the subgoals <code>B<sub>1</sub>, ..., B<sub>n</sub></code> of the chosen clause. These subgoals can also be executed in parallel. Thus concurrent logic programming implements a form of "don't care nondeterminism", rather than "don't know nondeterminism".
</p><p>For example, the following concurrent logic program defines a predicate <code>shuffle(Left, Right, Merge)</code>, which can be used to shuffle two lists <code>Left</code> and <code>Right</code>, combining them into a single list <code>Merge</code> that preserves the ordering of the two lists <code>Left</code> and <code>Right</code>:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">shuffle</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[]).</span>
<span class="nf">shuffle</span><span class="p">(</span><span class="nv">Left</span><span class="p">,</span> <span class="nv">Right</span><span class="p">,</span> <span class="nv">Merge</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Left</span> <span class="o">=</span> <span class="p">[</span><span class="nv">First</span> <span class="p">|</span> <span class="nv">Rest</span><span class="p">]</span> <span class="p">|</span>
    <span class="nv">Merge</span> <span class="o">=</span> <span class="p">[</span><span class="nv">First</span> <span class="p">|</span> <span class="nv">ShortMerge</span><span class="p">],</span>
    <span class="nf">shuffle</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span> <span class="nv">Right</span><span class="p">,</span> <span class="nv">ShortMerge</span><span class="p">).</span>
<span class="nf">shuffle</span><span class="p">(</span><span class="nv">Left</span><span class="p">,</span> <span class="nv">Right</span><span class="p">,</span> <span class="nv">Merge</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Right</span> <span class="o">=</span> <span class="p">[</span><span class="nv">First</span> <span class="p">|</span> <span class="nv">Rest</span><span class="p">]</span> <span class="p">|</span>
    <span class="nv">Merge</span> <span class="o">=</span> <span class="p">[</span><span class="nv">First</span> <span class="p">|</span> <span class="nv">ShortMerge</span><span class="p">],</span>
    <span class="nf">shuffle</span><span class="p">(</span><span class="nv">Left</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">ShortMerge</span><span class="p">).</span>
</pre></div>
<p>Here, <code>[]</code> represents the empty list, and <code>[Head | Tail]</code> represents a list with first element <code>Head</code> followed by list <code>Tail</code>, as in Prolog. (Notice that the first occurrence of <span class="nounderlines" style="border: 1px solid var(--border-color-muted,#ddd); color: var(--color-base); background-color: var( --background-color-neutral-subtle, #fdfdfd); padding: 1px 1px;">|</span> in the second and third clauses is the list constructor, whereas the second occurrence of <span class="nounderlines" style="border: 1px solid var(--border-color-muted,#ddd); color: var(--color-base); background-color: var( --background-color-neutral-subtle, #fdfdfd); padding: 1px 1px;">|</span> is the commitment operator.)  The program can be used, for example, to shuffle the lists <code>[ace, queen, king]</code> and <code>[1, 4, 2]</code> by invoking the goal clause:
</p>
<div class="mw-highlight mw-highlight-lang-prolog mw-content-ltr" dir="ltr"><pre><span></span><span class="nf">shuffle</span><span class="p">([</span><span class="s s-Atom">ace</span><span class="p">,</span> <span class="s s-Atom">queen</span><span class="p">,</span> <span class="s s-Atom">king</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nv">Merge</span><span class="p">).</span>
</pre></div>
<p>The program will non-deterministically generate a single solution, for example <code>Merge = [ace, queen, 1, king, 4, 2]</code>.
</p><p><a href="/wiki/Carl_Hewitt" title="Carl Hewitt">Carl Hewitt</a> has argued<sup id="cite_ref-Hewitt_68-0" class="reference"><a href="#cite_note-Hewitt-68"><span class="cite-bracket">&#91;</span>68<span class="cite-bracket">&#93;</span></a></sup> that, because of the <a href="/wiki/Indeterminacy_in_concurrent_computation" title="Indeterminacy in concurrent computation">indeterminacy of concurrent computation</a>, concurrent logic programming cannot implement general concurrency. However, according to the logical semantics, any result of a computation of a concurrent logic program is a logical consequence of the program, even though not all logical consequences can be derived.
</p>
<div class="mw-heading mw-heading3"><h3 id="Concurrent_constraint_logic_programming">Concurrent constraint logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=19" title="Edit section: Concurrent constraint logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236090951"><div role="note" class="hatnote navigation-not-searchable">Main article: <a href="/wiki/Concurrent_constraint_logic_programming" title="Concurrent constraint logic programming">Concurrent constraint logic programming</a></div>
<p><a href="/wiki/Concurrent_constraint_logic_programming" title="Concurrent constraint logic programming">Concurrent constraint logic programming</a><sup id="cite_ref-69" class="reference"><a href="#cite_note-69"><span class="cite-bracket">&#91;</span>69<span class="cite-bracket">&#93;</span></a></sup> combines concurrent logic programming and <a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">constraint logic programming</a>, using constraints to control concurrency. A clause can contain a guard, which is a set of constraints that may block the applicability of the clause. When the guards of several clauses are satisfied, concurrent constraint logic programming makes a committed choice to use only one.
</p>
<div class="mw-heading mw-heading3"><h3 id="Higher-order_logic_programming">Higher-order logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=20" title="Edit section: Higher-order logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>Several researchers have extended logic programming with <a href="/wiki/Higher-order_programming" title="Higher-order programming">higher-order programming</a> features derived from <a href="/wiki/Higher-order_logic" title="Higher-order logic">higher-order logic</a>, such as predicate variables. Such languages include the Prolog extensions <a href="/wiki/HiLog" title="HiLog">HiLog</a><sup id="cite_ref-hilog-jlp_70-0" class="reference"><a href="#cite_note-hilog-jlp-70"><span class="cite-bracket">&#91;</span>70<span class="cite-bracket">&#93;</span></a></sup> and <a href="/wiki/%CE%9BProlog" title="ΛProlog">λProlog</a>.<sup id="cite_ref-71" class="reference"><a href="#cite_note-71"><span class="cite-bracket">&#91;</span>71<span class="cite-bracket">&#93;</span></a></sup>
</p>
<div class="mw-heading mw-heading3"><h3 id="Linear_logic_programming">Linear logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=21" title="Edit section: Linear logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p>Basing logic programming within <a href="/wiki/Linear_logic" title="Linear logic">linear logic</a> has resulted in the design of logic programming languages that are considerably more expressive than those based on classical logic. Horn clause programs can only represent state change by the change in arguments to predicates. In linear logic programming, one can use the ambient linear logic to support state change. Some early designs of logic programming languages based on linear logic include LO,<sup id="cite_ref-72" class="reference"><a href="#cite_note-72"><span class="cite-bracket">&#91;</span>72<span class="cite-bracket">&#93;</span></a></sup> Lolli,<sup id="cite_ref-73" class="reference"><a href="#cite_note-73"><span class="cite-bracket">&#91;</span>73<span class="cite-bracket">&#93;</span></a></sup> ACL,<sup id="cite_ref-74" class="reference"><a href="#cite_note-74"><span class="cite-bracket">&#91;</span>74<span class="cite-bracket">&#93;</span></a></sup> and Forum.<sup id="cite_ref-75" class="reference"><a href="#cite_note-75"><span class="cite-bracket">&#91;</span>75<span class="cite-bracket">&#93;</span></a></sup> Forum provides a goal-directed interpretation of all linear logic.
</p>
<div class="mw-heading mw-heading3"><h3 id="Object-oriented_logic_programming">Object-oriented logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=22" title="Edit section: Object-oriented logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p><a href="/wiki/F-logic" title="F-logic">F-logic</a><sup id="cite_ref-76" class="reference"><a href="#cite_note-76"><span class="cite-bracket">&#91;</span>76<span class="cite-bracket">&#93;</span></a></sup> extends logic programming with objects and the frame syntax.
</p><p><a href="/wiki/Logtalk" title="Logtalk">Logtalk</a><sup id="cite_ref-77" class="reference"><a href="#cite_note-77"><span class="cite-bracket">&#91;</span>77<span class="cite-bracket">&#93;</span></a></sup> extends the Prolog programming language with support for objects, protocols, and other OOP concepts. It supports most standard-compliant Prolog systems as backend compilers.
</p>
<div class="mw-heading mw-heading3"><h3 id="Transaction_logic_programming">Transaction logic programming</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=23" title="Edit section: Transaction logic programming"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<p><a href="/wiki/Transaction_logic" title="Transaction logic">Transaction logic</a><sup id="cite_ref-TL_53-1" class="reference"><a href="#cite_note-TL-53"><span class="cite-bracket">&#91;</span>53<span class="cite-bracket">&#93;</span></a></sup> is an extension of logic programming with a logical theory of state-modifying updates. It has both a model-theoretic semantics and a procedural one. An implementation of a subset of Transaction logic is available in the <a href="/wiki/Flora-2" title="Flora-2">Flora-2</a><sup id="cite_ref-78" class="reference"><a href="#cite_note-78"><span class="cite-bracket">&#91;</span>78<span class="cite-bracket">&#93;</span></a></sup> system. Other prototypes are also <a href="/wiki/Transaction_logic" title="Transaction logic">available</a>.
</p>
<div class="mw-heading mw-heading2"><h2 id="See_also">See also</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=24" title="Edit section: See also"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<ul><li><a href="/wiki/Automated_theorem_proving" title="Automated theorem proving">Automated theorem proving</a></li>
<li><a href="/wiki/Boolean_satisfiability_problem" title="Boolean satisfiability problem">Boolean satisfiability problem</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic programming</a></li>
<li><a href="/wiki/Control_theory" title="Control theory">Control theory</a></li>
<li><a href="/wiki/Datalog" title="Datalog">Datalog</a></li>
<li><a href="/wiki/Fril" title="Fril">Fril</a></li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional programming</a></li>
<li><a href="/wiki/Fuzzy_logic" title="Fuzzy logic">Fuzzy logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic programming</a></li>
<li><a href="/wiki/Linear_logic" title="Linear logic">Linear logic</a></li>
<li><a href="/wiki/Logic_in_computer_science" title="Logic in computer science">Logic in computer science</a> (includes <a href="/wiki/Formal_methods" title="Formal methods">Formal methods</a>)</li>
<li><a href="/wiki/Category:Logic_programming_languages" title="Category:Logic programming languages">Logic programming languages</a></li>
<li><a href="/wiki/Programmable_logic_controller" title="Programmable logic controller">Programmable logic controller</a></li>
<li><a href="/wiki/R%2B%2B" title="R++">R++</a></li>
<li><a href="/wiki/Reasoning_system" title="Reasoning system">Reasoning system</a></li>
<li><a href="/wiki/Rule-based_machine_learning" title="Rule-based machine learning">Rule-based machine learning</a></li>
<li><a href="/wiki/Satisfiability" title="Satisfiability">Satisfiability</a></li>
<li><a href="/wiki/Syntax_and_semantics_of_logic_programming" title="Syntax and semantics of logic programming">Syntax and semantics of logic programming</a></li></ul>
<div class="mw-heading mw-heading2"><h2 id="Citations">Citations</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=25" title="Edit section: Citations"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<style data-mw-deduplicate="TemplateStyles:r1239543626">.mw-parser-output .reflist{margin-bottom:0.5em;list-style-type:decimal}@media screen{.mw-parser-output .reflist{font-size:90%}}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}</style><div class="reflist">
<div class="mw-references-wrap mw-references-columns"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><style data-mw-deduplicate="TemplateStyles:r1238218222">.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free.id-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited.id-lock-limited a,.mw-parser-output .id-lock-registration.id-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription.id-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-free a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-limited a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-registration a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-subscription a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .cs1-ws-icon a{background-size:contain;padding:0 1em 0 0}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:var(--color-error,#d33)}.mw-parser-output .cs1-visible-error{color:var(--color-error,#d33)}.mw-parser-output .cs1-maint{display:none;color:#085;margin-left:0.3em}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}@media screen{.mw-parser-output .cs1-format{font-size:95%}html.skin-theme-clientpref-night .mw-parser-output .cs1-maint{color:#18911f}}@media screen and (prefers-color-scheme:dark){html.skin-theme-clientpref-os .mw-parser-output .cs1-maint{color:#18911f}}</style><cite id="CITEREFTärnlund1977" class="citation journal cs1">Tärnlund, S.Å. (1977). "Horn clause computability". <i><a href="/wiki/BIT_Numerical_Mathematics" title="BIT Numerical Mathematics">BIT Numerical Mathematics</a></i>. <b>17</b> (2): <span class="nowrap">215–</span>226. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1007%2FBF01932293">10.1007/BF01932293</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:32577496">32577496</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=BIT+Numerical+Mathematics&amp;rft.atitle=Horn+clause+computability&amp;rft.volume=17&amp;rft.issue=2&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E215-%3C%2Fspan%3E226&amp;rft.date=1977&amp;rft_id=info%3Adoi%2F10.1007%2FBF01932293&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A32577496%23id-name%3DS2CID&amp;rft.aulast=T%C3%A4rnlund&amp;rft.aufirst=S.%C3%85.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFAndrékaNémeti1978" class="citation journal cs1">Andréka, H.; Németi, I. (1978). <a rel="nofollow" class="external text" href="https://cyber.bibl.u-szeged.hu/index.php/actcybern/article/view/3160">"The generalised completeness of Horn predicate-logic as a programming language"</a>. <i>Acta Cybernetica</i>. <b>4</b> (1): <span class="nowrap">3–</span>10.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Acta+Cybernetica&amp;rft.atitle=The+generalised+completeness+of+Horn+predicate-logic+as+a+programming+language&amp;rft.volume=4&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E3-%3C%2Fspan%3E10&amp;rft.date=1978&amp;rft.aulast=Andr%C3%A9ka&amp;rft.aufirst=H.&amp;rft.au=N%C3%A9meti%2C+I.&amp;rft_id=https%3A%2F%2Fcyber.bibl.u-szeged.hu%2Findex.php%2Factcybern%2Farticle%2Fview%2F3160&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFGreen" class="citation conference cs1">Green, Cordell. <a rel="nofollow" class="external text" href="https://www.ijcai.org/Proceedings/69/Papers/023.pdf"><i>Application of Theorem Proving to Problem Solving</i></a> <span class="cs1-format">(PDF)</span>. IJCAI 1969.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.btitle=Application+of+Theorem+Proving+to+Problem+Solving&amp;rft.aulast=Green&amp;rft.aufirst=Cordell&amp;rft_id=https%3A%2F%2Fwww.ijcai.org%2FProceedings%2F69%2FPapers%2F023.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFFosterElcock1969" class="citation conference cs1">Foster, J.M.; Elcock, E.W. (1969). <i>ABSYS 1: An Incremental Compiler for Assertions: an Introduction</i>. Fourth Annual Machine Intelligence Workshop. Machine Intelligence. Vol.&#160;4. Edinburgh, UK: <a href="/wiki/Edinburgh_University_Press" title="Edinburgh University Press">Edinburgh University Press</a>. pp.&#160;<span class="nowrap">423–</span>429.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.btitle=ABSYS+1%3A+An+Incremental+Compiler+for+Assertions%3A+an+Introduction&amp;rft.place=Edinburgh%2C+UK&amp;rft.series=Machine+Intelligence&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E423-%3C%2Fspan%3E429&amp;rft.pub=Edinburgh+University+Press&amp;rft.date=1969&amp;rft.aulast=Foster&amp;rft.aufirst=J.M.&amp;rft.au=Elcock%2C+E.W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKowalski1988" class="citation journal cs1">Kowalski, R. A. (1988). <a rel="nofollow" class="external text" href="http://www.doc.ic.ac.uk/~rak/papers/the%20early%20years.pdf">"The early years of logic programming"</a> <span class="cs1-format">(PDF)</span>. <i>Communications of the ACM</i>. <b>31</b>: <span class="nowrap">38–</span>43. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F35043.35046">10.1145/35043.35046</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:12259230">12259230</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=The+early+years+of+logic+programming&amp;rft.volume=31&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E38-%3C%2Fspan%3E43&amp;rft.date=1988&amp;rft_id=info%3Adoi%2F10.1145%2F35043.35046&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A12259230%23id-name%3DS2CID&amp;rft.aulast=Kowalski&amp;rft.aufirst=R.+A.&amp;rft_id=http%3A%2F%2Fwww.doc.ic.ac.uk%2F~rak%2Fpapers%2Fthe%2520early%2520years.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFHewitt" class="citation conference cs1"><a href="/wiki/Carl_Hewitt" title="Carl Hewitt">Hewitt, Carl</a>. <a rel="nofollow" class="external text" href="https://www.ijcai.org/Proceedings/69/Papers/030.pdf"><i>Planner: A Language for Proving Theorems in Robots</i></a> <span class="cs1-format">(PDF)</span>. IJCAI 1969.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.btitle=Planner%3A+A+Language+for+Proving+Theorems+in+Robots&amp;rft.aulast=Hewitt&amp;rft.aufirst=Carl&amp;rft_id=https%3A%2F%2Fwww.ijcai.org%2FProceedings%2F69%2FPapers%2F030.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-Winograd-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-Winograd_7-0">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFWinograd1972" class="citation journal cs1"><a href="/wiki/Terry_Winograd" title="Terry Winograd">Winograd, Terry</a> (1972). "Understanding natural language". <i><a href="/wiki/Cognitive_Psychology_(journal)" title="Cognitive Psychology (journal)">Cognitive Psychology</a></i>. <b>3</b> (1): <span class="nowrap">1–</span>191. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0010-0285%2872%2990002-3">10.1016/0010-0285(72)90002-3</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Psychology&amp;rft.atitle=Understanding+natural+language&amp;rft.volume=3&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E1-%3C%2Fspan%3E191&amp;rft.date=1972&amp;rft_id=info%3Adoi%2F10.1016%2F0010-0285%2872%2990002-3&amp;rft.aulast=Winograd&amp;rft.aufirst=Terry&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-Rulifson-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-Rulifson_8-0">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFJeff_RulifsonJan_DerksenRichard_Waldinger1973" class="citation techreport cs1"><a href="/wiki/Jeff_Rulifson" title="Jeff Rulifson">Jeff Rulifson</a>; Jan Derksen; Richard Waldinger (November 1973). <a rel="nofollow" class="external text" href="https://apps.dtic.mil/sti/pdfs/ADA052440.pdf"><i>QA4, A Procedural Calculus for Intuitive Reasoning</i></a> <span class="cs1-format">(PDF)</span> (Technical report). SRI AI Center Technical Note 73.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=report&amp;rft.btitle=QA4%2C+A+Procedural+Calculus+for+Intuitive+Reasoning&amp;rft.date=1973-11&amp;rft.au=Jeff+Rulifson&amp;rft.au=Jan+Derksen&amp;rft.au=Richard+Waldinger&amp;rft_id=https%3A%2F%2Fapps.dtic.mil%2Fsti%2Fpdfs%2FADA052440.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text">Davies, J.M., 1971. POPLER: a POP-2 planner. Edinburgh University, Department of Machine Intelligence and Perception.</span>
</li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFMcDermottSussman1972" class="citation techreport cs1"><a href="/wiki/Drew_McDermott" title="Drew McDermott">McDermott, D.V.</a>; <a href="/wiki/Gerald_Jay_Sussman" title="Gerald Jay Sussman">Sussman, G.J.</a> (May 1972). <a rel="nofollow" class="external text" href="https://www.researchgate.net/publication/37597046_The_Conniver_Reference_Manual"><i>The Conniver reference manual</i></a> (Technical report). Artificial Intelligence Memo No. 259.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=report&amp;rft.btitle=The+Conniver+reference+manual&amp;rft.date=1972-05&amp;rft.aulast=McDermott&amp;rft.aufirst=D.V.&amp;rft.au=Sussman%2C+G.J.&amp;rft_id=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F37597046_The_Conniver_Reference_Manual&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFRebohSacerdoti1973" class="citation techreport cs1">Reboh, R.; Sacerdoti, E.D. (August 1973). <a rel="nofollow" class="external text" href="https://www.sri.com/publication/cyber-formal-methods-pubs/preliminary-qlisp-manual/"><i>A preliminary QLISP manual</i></a> (Technical report). Artificial Intelligence Center, SRI International.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=report&amp;rft.btitle=A+preliminary+QLISP+manual&amp;rft.pub=Artificial+Intelligence+Center%2C+SRI+International&amp;rft.date=1973-08&amp;rft.aulast=Reboh&amp;rft.aufirst=R.&amp;rft.au=Sacerdoti%2C+E.D.&amp;rft_id=https%3A%2F%2Fwww.sri.com%2Fpublication%2Fcyber-formal-methods-pubs%2Fpreliminary-qlisp-manual%2F&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKornfeldHewitt1981" class="citation journal cs1">Kornfeld, W.A.; <a href="/wiki/Carl_Hewitt" title="Carl Hewitt">Hewitt, C.E.</a> (1981). "The scientific community metaphor". <i>IEEE Transactions on Systems, Man, and Cybernetics</i>. <b>11</b> (1): <span class="nowrap">24–</span>33. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1109%2FTSMC.1981.4308575">10.1109/TSMC.1981.4308575</a>. <a href="/wiki/Hdl_(identifier)" class="mw-redirect" title="Hdl (identifier)">hdl</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://hdl.handle.net/1721.1%2F5693">1721.1/5693</a></span>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:1322857">1322857</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=IEEE+Transactions+on+Systems%2C+Man%2C+and+Cybernetics&amp;rft.atitle=The+scientific+community+metaphor&amp;rft.volume=11&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E24-%3C%2Fspan%3E33&amp;rft.date=1981&amp;rft_id=info%3Ahdl%2F1721.1%2F5693&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A1322857%23id-name%3DS2CID&amp;rft_id=info%3Adoi%2F10.1109%2FTSMC.1981.4308575&amp;rft.aulast=Kornfeld&amp;rft.aufirst=W.A.&amp;rft.au=Hewitt%2C+C.E.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFHayes1973" class="citation conference cs1">Hayes, Pat (1973). "Computation and Deduction". <i>Proceedings of the 2nd MFCS Symposium</i>. <a href="/wiki/Czechoslovak_Academy_of_Sciences" title="Czechoslovak Academy of Sciences">Czechoslovak Academy of Sciences</a>. pp.&#160;<span class="nowrap">105–</span>118.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.atitle=Computation+and+Deduction&amp;rft.btitle=Proceedings+of+the+2nd+MFCS+Symposium&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E105-%3C%2Fspan%3E118&amp;rft.pub=Czechoslovak+Academy+of+Sciences&amp;rft.date=1973&amp;rft.aulast=Hayes&amp;rft.aufirst=Pat&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFRobinson1965" class="citation journal cs1">Robinson, J. (1965). "Automatic deduction with hyper-resolution". <i><a href="/wiki/International_Journal_of_Computer_Mathematics" title="International Journal of Computer Mathematics">International Journal of Computer Mathematics</a></i>. <b>1</b> (3): <span class="nowrap">227–</span>234. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.2307%2F2272384">10.2307/2272384</a>. <a href="/wiki/JSTOR_(identifier)" class="mw-redirect" title="JSTOR (identifier)">JSTOR</a>&#160;<a rel="nofollow" class="external text" href="https://www.jstor.org/stable/2272384">2272384</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=International+Journal+of+Computer+Mathematics&amp;rft.atitle=Automatic+deduction+with+hyper-resolution&amp;rft.volume=1&amp;rft.issue=3&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E227-%3C%2Fspan%3E234&amp;rft.date=1965&amp;rft_id=info%3Adoi%2F10.2307%2F2272384&amp;rft_id=https%3A%2F%2Fwww.jstor.org%2Fstable%2F2272384%23id-name%3DJSTOR&amp;rft.aulast=Robinson&amp;rft.aufirst=J.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKowalskiKuehner1971" class="citation journal cs1">Kowalski, Robert; Kuehner, Donald (1971). <a rel="nofollow" class="external text" href="http://www.doc.ic.ac.uk/~rak/papers/sl.pdf">"Linear Resolution with Selection Function"</a> <span class="cs1-format">(PDF)</span>. <i><a href="/wiki/Artificial_Intelligence_(journal)" title="Artificial Intelligence (journal)">Artificial Intelligence</a></i>. <b>2</b> (<span class="nowrap">3–</span>4): <span class="nowrap">227–</span>260. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0004-3702%2871%2990012-9">10.1016/0004-3702(71)90012-9</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.atitle=Linear+Resolution+with+Selection+Function&amp;rft.volume=2&amp;rft.issue=%3Cspan+class%3D%22nowrap%22%3E3%E2%80%93%3C%2Fspan%3E4&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E227-%3C%2Fspan%3E260&amp;rft.date=1971&amp;rft_id=info%3Adoi%2F10.1016%2F0004-3702%2871%2990012-9&amp;rft.aulast=Kowalski&amp;rft.aufirst=Robert&amp;rft.au=Kuehner%2C+Donald&amp;rft_id=http%3A%2F%2Fwww.doc.ic.ac.uk%2F~rak%2Fpapers%2Fsl.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-Kowalski-16"><span class="mw-cite-backlink"><b><a href="#cite_ref-Kowalski_16-0">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKowalski1973" class="citation web cs1">Kowalski, Robert (1973). <a rel="nofollow" class="external text" href="https://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf">"Predicate Logic as a Programming Language"</a> <span class="cs1-format">(PDF)</span>. Department of Artificial Intelligence, <a href="/wiki/Edinburgh_University" class="mw-redirect" title="Edinburgh University">Edinburgh University</a>. Memo 70.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Predicate+Logic+as+a+Programming+Language&amp;rft.pub=Department+of+Artificial+Intelligence%2C+Edinburgh+University&amp;rft.date=1973&amp;rft.aulast=Kowalski&amp;rft.aufirst=Robert&amp;rft_id=https%3A%2F%2Fwww.doc.ic.ac.uk%2F~rak%2Fpapers%2FIFIP%252074.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span> Also in Proceedings IFIP Congress, Stockholm, North Holland Publishing Co., 1974, pp.&#160;569–574.</span>
</li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFWarrenPereiraPereira1977" class="citation journal cs1">Warren, D.H.; Pereira, L.M.; Pereira, F. (1977). "Prolog-the language and its implementation compared with Lisp". <i><a href="/wiki/ACM_SIGPLAN_Notices" class="mw-redirect" title="ACM SIGPLAN Notices">ACM SIGPLAN Notices</a></i>. <b>12</b> (8): <span class="nowrap">109–</span>115. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F872734.806939">10.1145/872734.806939</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=ACM+SIGPLAN+Notices&amp;rft.atitle=Prolog-the+language+and+its+implementation+compared+with+Lisp&amp;rft.volume=12&amp;rft.issue=8&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E109-%3C%2Fspan%3E115&amp;rft.date=1977&amp;rft_id=info%3Adoi%2F10.1145%2F872734.806939&amp;rft.aulast=Warren&amp;rft.aufirst=D.H.&amp;rft.au=Pereira%2C+L.M.&amp;rft.au=Pereira%2C+F.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text">Ueda, K., 2018. Logic/constraint programming and concurrency: The hard-won lessons of the fifth generation computer project. Science of Computer Programming, 164, pp.3-17.</span>
</li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text">H.P. Newquist, 2020. The Brain Makers: The History Of Artificial Intelligence. The Relayer Group.</span>
</li>
<li id="cite_note-20"><span class="mw-cite-backlink"><b><a href="#cite_ref-20">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFGallaireMinker1978" class="citation cs2">Gallaire, Hervé; Minker, John 'Jack', eds. (1978), "Logic and Data Bases, Symposium on Logic and Data Bases, Centre d'études et de recherches de Toulouse, 1977", <span class="id-lock-registration" title="Free registration required"><a rel="nofollow" class="external text" href="https://archive.org/details/logicdatabases0000symp"><i>Advances in Data Base Theory</i></a></span>, New York: Plenum Press, <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-0-306-40060-5" title="Special:BookSources/978-0-306-40060-5"><bdi>978-0-306-40060-5</bdi></a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Logic+and+Data+Bases%2C+Symposium+on+Logic+and+Data+Bases%2C+Centre+d%27%C3%A9tudes+et+de+recherches+de+Toulouse%2C+1977&amp;rft.btitle=Advances+in+Data+Base+Theory&amp;rft.place=New+York&amp;rft.pub=Plenum+Press&amp;rft.date=1978&amp;rft.isbn=978-0-306-40060-5&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Flogicdatabases0000symp&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span>.</span>
</li>
<li id="cite_note-Prolog_Book-21"><span class="mw-cite-backlink">^ <a href="#cite_ref-Prolog_Book_21-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Prolog_Book_21-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFWarren2023" class="citation book cs1">Warren, D.S. (2023). "Introduction to Prolog". In Warren, D.S.; Dahl, V.; Eiter, T.; Hermenegildo, M.V.; Kowalski, R.; Rossi, F. (eds.). <i>Prolog: The Next 50 Years</i>. Lecture Notes in Computer Science(). Vol.&#160;13900. Springer, Cham. pp.&#160;<span class="nowrap">3–</span>19. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1007%2F978-3-031-35254-6_1">10.1007/978-3-031-35254-6_1</a>. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-3-031-35253-9" title="Special:BookSources/978-3-031-35253-9"><bdi>978-3-031-35253-9</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Introduction+to+Prolog&amp;rft.btitle=Prolog%3A+The+Next+50+Years&amp;rft.series=Lecture+Notes+in+Computer+Science%28%29&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E3-%3C%2Fspan%3E19&amp;rft.pub=Springer%2C+Cham.&amp;rft.date=2023&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-031-35254-6_1&amp;rft.isbn=978-3-031-35253-9&amp;rft.aulast=Warren&amp;rft.aufirst=D.S.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-22"><span class="mw-cite-backlink"><b><a href="#cite_ref-22">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFRobinson2001" class="citation journal cs1">Robinson, J. Alan (2001). "Invited Editorial". <i>Theory and Practice of Logic Programming</i>. <b>1</b> (1). <a href="/wiki/Cambridge_University_Press" title="Cambridge University Press">Cambridge University Press</a>: 1. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1017%2Fs1471068400000028">10.1017/s1471068400000028</a></span> (inactive 1 November 2024).</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theory+and+Practice+of+Logic+Programming&amp;rft.atitle=Invited+Editorial&amp;rft.volume=1&amp;rft.issue=1&amp;rft.pages=1&amp;rft.date=2001&amp;rft_id=info%3Adoi%2F10.1017%2Fs1471068400000028&amp;rft.aulast=Robinson&amp;rft.aufirst=J.+Alan&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span><span class="cs1-maint citation-comment"><code class="cs1-code">{{<a href="/wiki/Template:Cite_journal" title="Template:Cite journal">cite journal</a>}}</code>:  CS1 maint: DOI inactive as of November 2024 (<a href="/wiki/Category:CS1_maint:_DOI_inactive_as_of_November_2024" title="Category:CS1 maint: DOI inactive as of November 2024">link</a>)</span></span>
</li>
<li id="cite_note-23"><span class="mw-cite-backlink"><b><a href="#cite_ref-23">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFR.A.Kowalski1979" class="citation journal cs1">R.A.Kowalski (July 1979). <a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F359131.359136">"Algorithm=Logic + Control"</a>. <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i>. <b>22</b> (7): <span class="nowrap">424–</span>436. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F359131.359136">10.1145/359131.359136</a></span>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:2509896">2509896</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=Algorithm%3DLogic+%2B+Control&amp;rft.volume=22&amp;rft.issue=7&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E424-%3C%2Fspan%3E436&amp;rft.date=1979-07&amp;rft_id=info%3Adoi%2F10.1145%2F359131.359136&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A2509896%23id-name%3DS2CID&amp;rft.au=R.A.Kowalski&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1145%252F359131.359136&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-24"><span class="mw-cite-backlink"><b><a href="#cite_ref-24">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFBruynooghePereira1984" class="citation book cs1">Bruynooghe, M.; Pereira, L.M. (1984). "Deduction revision by intelligent backtracking". <i>Implementations of Prolog</i>. Chichester, England: Ellis Horwood. pp.&#160;<span class="nowrap">194–</span>215.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Deduction+revision+by+intelligent+backtracking&amp;rft.btitle=Implementations+of+Prolog&amp;rft.place=Chichester%2C+England&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E194-%3C%2Fspan%3E215&amp;rft.pub=Ellis+Horwood&amp;rft.date=1984&amp;rft.aulast=Bruynooghe&amp;rft.aufirst=M.&amp;rft.au=Pereira%2C+L.M.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-25"><span class="mw-cite-backlink"><b><a href="#cite_ref-25">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFNakamura1985" class="citation conference cs1">Nakamura, K. (July 1985). <i>Heuristic Prolog: logic program execution by heuristic search</i>. Conference on Logic Programming. Berlin, Heidelberg: Springer Berlin Heidelberg. pp.&#160;<span class="nowrap">148–</span>155.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.btitle=Heuristic+Prolog%3A+logic+program+execution+by+heuristic+search&amp;rft.place=Berlin%2C+Heidelberg&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E148-%3C%2Fspan%3E155&amp;rft.pub=Springer+Berlin+Heidelberg&amp;rft.date=1985-07&amp;rft.aulast=Nakamura&amp;rft.aufirst=K.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-26"><span class="mw-cite-backlink"><b><a href="#cite_ref-26">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFGeneserethGinsberg1985" class="citation journal cs1">Genesereth, M.R.; Ginsberg, M.L. (1985). <a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F4284.4287">"Logic programming"</a>. <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i>. <b>28</b> (9): <span class="nowrap">933–</span>941. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F4284.4287">10.1145/4284.4287</a></span>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:15527861">15527861</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=Logic+programming&amp;rft.volume=28&amp;rft.issue=9&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E933-%3C%2Fspan%3E941&amp;rft.date=1985&amp;rft_id=info%3Adoi%2F10.1145%2F4284.4287&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A15527861%23id-name%3DS2CID&amp;rft.aulast=Genesereth&amp;rft.aufirst=M.R.&amp;rft.au=Ginsberg%2C+M.L.&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1145%252F4284.4287&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-27"><span class="mw-cite-backlink"><b><a href="#cite_ref-27">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFSwiftWarren2012" class="citation journal cs1">Swift, T.; Warren, D.S. (January 2012). "XSB: Extending Prolog with tabled logic programming". <i><a href="/wiki/Theory_and_Practice_of_Logic_Programming" class="mw-redirect" title="Theory and Practice of Logic Programming">Theory and Practice of Logic Programming</a></i>. <b>12</b> (<span class="nowrap">1–</span>2): <span class="nowrap">157–</span>187. <a href="/wiki/ArXiv_(identifier)" class="mw-redirect" title="ArXiv (identifier)">arXiv</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://arxiv.org/abs/1012.5123">1012.5123</a></span>. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1017%2FS1471068411000500">10.1017/S1471068411000500</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:6153112">6153112</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theory+and+Practice+of+Logic+Programming&amp;rft.atitle=XSB%3A+Extending+Prolog+with+tabled+logic+programming&amp;rft.volume=12&amp;rft.issue=%3Cspan+class%3D%22nowrap%22%3E1%E2%80%93%3C%2Fspan%3E2&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E157-%3C%2Fspan%3E187&amp;rft.date=2012-01&amp;rft_id=info%3Aarxiv%2F1012.5123&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A6153112%23id-name%3DS2CID&amp;rft_id=info%3Adoi%2F10.1017%2FS1471068411000500&amp;rft.aulast=Swift&amp;rft.aufirst=T.&amp;rft.au=Warren%2C+D.S.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-dis-28"><span class="mw-cite-backlink">^ <a href="#cite_ref-dis_28-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-dis_28-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFDaniel_FriedmanWilliam_ByrdOleg_KiselyovJason_Hemann2018" class="citation book cs1">Daniel Friedman; William Byrd; Oleg Kiselyov; Jason Hemann (2018). <i>The Reasoned Schemer, Second Edition</i>. The MIT Press.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Reasoned+Schemer%2C+Second+Edition&amp;rft.pub=The+MIT+Press&amp;rft.date=2018&amp;rft.au=Daniel+Friedman&amp;rft.au=William+Byrd&amp;rft.au=Oleg+Kiselyov&amp;rft.au=Jason+Hemann&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-29"><span class="mw-cite-backlink"><b><a href="#cite_ref-29">^</a></b></span> <span class="reference-text">A. Casas, D. Cabeza, M. V. Hermenegildo. A Syntactic Approach to
  Combining Functional Notation, Lazy Evaluation and Higher-Order in
  LP Systems. The 8th International Symposium on Functional and Logic   Programming (FLOPS'06), pages 142-162, April 2006.</span>
</li>
<li id="cite_note-30"><span class="mw-cite-backlink"><b><a href="#cite_ref-30">^</a></b></span> <span class="reference-text">Kersting, K., Mladenov, M. and Tokmakov, P., 2017. Relational linear programming. Artificial Intelligence, 244, pp.188-216.</span>
</li>
<li id="cite_note-31"><span class="mw-cite-backlink"><b><a href="#cite_ref-31">^</a></b></span> <span class="reference-text">Beyer, D., 2006, May. Relational programming with CrocoPat. In Proceedings of the 28th International Conference on Software engineering (pp. 807-810).</span>
</li>
<li id="cite_note-32"><span class="mw-cite-backlink"><b><a href="#cite_ref-32">^</a></b></span> <span class="reference-text">MacLennan, B.J., 1983. Overview of relational programming. ACM SIGPLAN Notices, 18(3), pp.36-45.</span>
</li>
<li id="cite_note-33"><span class="mw-cite-backlink"><b><a href="#cite_ref-33">^</a></b></span> <span class="reference-text">Behnke, R., Berghammer, R., Meyer, E. and Schneider, P., 1998. RELVIEW—A system for calculating with relations and relational programming. In Fundamental Approaches to Software Engineering: First International Conference, FASE'98 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS'98 Lisbon, Portugal, March 28–April 4, 1998 Proceedings 1 (pp. 318-321). Springer Berlin Heidelberg.</span>
</li>
<li id="cite_note-34"><span class="mw-cite-backlink"><b><a href="#cite_ref-34">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFVan_EmdenKowalski1976" class="citation journal cs1">Van Emden, M.H.; Kowalski, R.A. (October 1976). <a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F321978.321991">"The semantics of predicate logic as a programming language"</a>. <i><a href="/wiki/Journal_of_the_ACM" title="Journal of the ACM">Journal of the ACM</a></i>. <b>23</b> (4): <span class="nowrap">733–</span>742. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F321978.321991">10.1145/321978.321991</a></span>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:11048276">11048276</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+the+ACM&amp;rft.atitle=The+semantics+of+predicate+logic+as+a+programming+language&amp;rft.volume=23&amp;rft.issue=4&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E733-%3C%2Fspan%3E742&amp;rft.date=1976-10&amp;rft_id=info%3Adoi%2F10.1145%2F321978.321991&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A11048276%23id-name%3DS2CID&amp;rft.aulast=Van+Emden&amp;rft.aufirst=M.H.&amp;rft.au=Kowalski%2C+R.A.&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1145%252F321978.321991&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-35"><span class="mw-cite-backlink"><b><a href="#cite_ref-35">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFClark1977" class="citation book cs1"><a href="/wiki/Keith_Clark_(computer_scientist)" title="Keith Clark (computer scientist)">Clark, K.L.</a> (1977). "Negation as Failure". <i>Logic and Data Bases</i>. Boston, MA: Springer US. pp.&#160;<span class="nowrap">293–</span>322. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1007%2F978-1-4684-3384-5_11">10.1007/978-1-4684-3384-5_11</a>. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-1-4684-3386-9" title="Special:BookSources/978-1-4684-3386-9"><bdi>978-1-4684-3386-9</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Negation+as+Failure&amp;rft.btitle=Logic+and+Data+Bases&amp;rft.place=Boston%2C+MA&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E293-%3C%2Fspan%3E322&amp;rft.pub=Springer+US&amp;rft.date=1977&amp;rft_id=info%3Adoi%2F10.1007%2F978-1-4684-3384-5_11&amp;rft.isbn=978-1-4684-3386-9&amp;rft.aulast=Clark&amp;rft.aufirst=K.L.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-36"><span class="mw-cite-backlink"><b><a href="#cite_ref-36">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFGelfondPrzymusinskaPrzymusinski1989" class="citation journal cs1">Gelfond, M.; Przymusinska, H.; Przymusinski, T. (1989). "On the relationship between circumscription and negation as failure". <i><a href="/wiki/Artificial_Intelligence_(journal)" title="Artificial Intelligence (journal)">Artificial Intelligence</a></i>. <b>38</b> (1): <span class="nowrap">75–</span>94. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0004-3702%2889%2990068-4">10.1016/0004-3702(89)90068-4</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.atitle=On+the+relationship+between+circumscription+and+negation+as+failure&amp;rft.volume=38&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E75-%3C%2Fspan%3E94&amp;rft.date=1989&amp;rft_id=info%3Adoi%2F10.1016%2F0004-3702%2889%2990068-4&amp;rft.aulast=Gelfond&amp;rft.aufirst=M.&amp;rft.au=Przymusinska%2C+H.&amp;rft.au=Przymusinski%2C+T.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-37"><span class="mw-cite-backlink"><b><a href="#cite_ref-37">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFShepherdson1984" class="citation journal cs1">Shepherdson, J.C. (1984). "Negation as failure: a comparison of Clark's completed data base and Reiter's closed world assumption". <i><a href="/wiki/The_Journal_of_Logic_Programming" class="mw-redirect" title="The Journal of Logic Programming">The Journal of Logic Programming</a></i>. <b>1</b> (1): <span class="nowrap">51–</span>79. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0743-1066%2884%2990023-2">10.1016/0743-1066(84)90023-2</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.atitle=Negation+as+failure%3A+a+comparison+of+Clark%27s+completed+data+base+and+Reiter%27s+closed+world+assumption&amp;rft.volume=1&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E51-%3C%2Fspan%3E79&amp;rft.date=1984&amp;rft_id=info%3Adoi%2F10.1016%2F0743-1066%2884%2990023-2&amp;rft.aulast=Shepherdson&amp;rft.aufirst=J.C.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-38"><span class="mw-cite-backlink"><b><a href="#cite_ref-38">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFDeneckerTernovska2008" class="citation journal cs1">Denecker, M.; Ternovska, E. (2008). <a rel="nofollow" class="external text" href="https://lirias.kuleuven.be/handle/123456789/222628">"A logic of nonmonotone inductive definitions"</a>. <i><a href="/wiki/ACM_Transactions_on_Computational_Logic" title="ACM Transactions on Computational Logic">ACM Transactions on Computational Logic</a></i>. <b>9</b> (2): 14:1–14:52. <a href="/wiki/ArXiv_(identifier)" class="mw-redirect" title="ArXiv (identifier)">arXiv</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://arxiv.org/abs/cs/0501025">cs/0501025</a></span>. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F1342991.1342998">10.1145/1342991.1342998</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:13156469">13156469</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=ACM+Transactions+on+Computational+Logic&amp;rft.atitle=A+logic+of+nonmonotone+inductive+definitions&amp;rft.volume=9&amp;rft.issue=2&amp;rft.pages=14%3A1-14%3A52&amp;rft.date=2008&amp;rft_id=info%3Aarxiv%2Fcs%2F0501025&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A13156469%23id-name%3DS2CID&amp;rft_id=info%3Adoi%2F10.1145%2F1342991.1342998&amp;rft.aulast=Denecker&amp;rft.aufirst=M.&amp;rft.au=Ternovska%2C+E.&amp;rft_id=https%3A%2F%2Flirias.kuleuven.be%2Fhandle%2F123456789%2F222628&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-39"><span class="mw-cite-backlink"><b><a href="#cite_ref-39">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFRaoSagonasSwiftWarren1997" class="citation conference cs1">Rao, P.; Sagonas, K.; Swift, T.; Warren, D.S.; Freire, J. (July 28–31, 1997). <i>XSB: A system for efficiently computing well-founded semantics</i>. Logic Programming And Nonmonotonic Reasoning: 4th International Conference, LPNMR'97. Dagstuhl Castle, Germany: Springer Berlin Heidelberg. pp.&#160;<span class="nowrap">430–</span>440. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1007%2F3-540-63255-7_33">10.1007/3-540-63255-7_33</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.btitle=XSB%3A+A+system+for+efficiently+computing+well-founded+semantics&amp;rft.place=Dagstuhl+Castle%2C+Germany&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E430-%3C%2Fspan%3E440&amp;rft.pub=Springer+Berlin+Heidelberg&amp;rft.date=1997-07-28%2F1997-07-31&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-63255-7_33&amp;rft.aulast=Rao&amp;rft.aufirst=P.&amp;rft.au=Sagonas%2C+K.&amp;rft.au=Swift%2C+T.&amp;rft.au=Warren%2C+D.S.&amp;rft.au=Freire%2C+J.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-40"><span class="mw-cite-backlink"><b><a href="#cite_ref-40">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFW._ChenD._S._Warren1996" class="citation journal cs1">W. Chen; D. S. Warren (January 1996). <a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F227595.227597">"Tabled Evaluation with Delaying for General Logic Programs"</a>. <i><a href="/wiki/Journal_of_the_ACM" title="Journal of the ACM">Journal of the ACM</a></i>. <b>43</b> (1): <span class="nowrap">20–</span>74. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F227595.227597">10.1145/227595.227597</a></span>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:7041379">7041379</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+the+ACM&amp;rft.atitle=Tabled+Evaluation+with+Delaying+for+General+Logic+Programs&amp;rft.volume=43&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E20-%3C%2Fspan%3E74&amp;rft.date=1996-01&amp;rft_id=info%3Adoi%2F10.1145%2F227595.227597&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A7041379%23id-name%3DS2CID&amp;rft.au=W.+Chen&amp;rft.au=D.+S.+Warren&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1145%252F227595.227597&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-41"><span class="mw-cite-backlink"><b><a href="#cite_ref-41">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFPhan_Minh_Dung1995" class="citation journal cs1">Phan Minh Dung (1995). <a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0004-3702%2894%2900041-X">"On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming, and n–person games"</a>. <i>Artificial Intelligence</i>. <b>77</b> (2): <span class="nowrap">321–</span>357. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0004-3702%2894%2900041-X">10.1016/0004-3702(94)00041-X</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.atitle=On+the+acceptability+of+arguments+and+its+fundamental+role+in+nonmonotonic+reasoning%2C+logic+programming%2C+and+n%E2%80%93person+games&amp;rft.volume=77&amp;rft.issue=2&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E321-%3C%2Fspan%3E357&amp;rft.date=1995&amp;rft_id=info%3Adoi%2F10.1016%2F0004-3702%2894%2900041-X&amp;rft.au=Phan+Minh+Dung&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1016%252F0004-3702%252894%252900041-X&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-42"><span class="mw-cite-backlink"><b><a href="#cite_ref-42">^</a></b></span> <span class="reference-text">Colmerauer, A. and Roussel, P., 1996. The birth of Prolog. In History of programming languages---II (pp. 331-367).</span>
</li>
<li id="cite_note-Warren-43"><span class="mw-cite-backlink">^ <a href="#cite_ref-Warren_43-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Warren_43-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Warren, D.H., Pereira, L.M. and Pereira, F., 1977. Prolog-the language and its implementation compared with Lisp. ACM SIGPLAN Notices, 12(8), pp.109-115.</span>
</li>
<li id="cite_note-44"><span class="mw-cite-backlink"><b><a href="#cite_ref-44">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFThagard2005" class="citation book cs1">Thagard, Paul (2005). <i>Mind: Introduction to Cognitive Science</i>. The MIT Press. p.&#160;11. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/9780262701099" title="Special:BookSources/9780262701099"><bdi>9780262701099</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Mind%3A+Introduction+to+Cognitive+Science&amp;rft.pages=11&amp;rft.pub=The+MIT+Press&amp;rft.date=2005&amp;rft.isbn=9780262701099&amp;rft.aulast=Thagard&amp;rft.aufirst=Paul&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span><a rel="nofollow" class="external free" href="https://www.google.co.uk/books/edition/Mind_second_edition/gjcR1U2HT7kC?hl=en&amp;gbpv=1&amp;pg=PP11&amp;printsec=frontcover">https://www.google.co.uk/books/edition/Mind_second_edition/gjcR1U2HT7kC?hl=en&amp;gbpv=1&amp;pg=PP11&amp;printsec=frontcover</a></span>
</li>
<li id="cite_note-45"><span class="mw-cite-backlink"><b><a href="#cite_ref-45">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFStenningvan_Lambalgen,_Michiel2008" class="citation book cs1">Stenning, Keith; van Lambalgen, Michiel (2008). <span class="id-lock-registration" title="Free registration required"><a rel="nofollow" class="external text" href="https://archive.org/details/humanreasoni_sten_2008_000_10735669"><i>Human reasoning and cognitive science</i></a></span>. <a href="/wiki/MIT_Press" title="MIT Press">MIT Press</a>. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-0-262-19583-6" title="Special:BookSources/978-0-262-19583-6"><bdi>978-0-262-19583-6</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Human+reasoning+and+cognitive+science&amp;rft.pub=MIT+Press&amp;rft.date=2008&amp;rft.isbn=978-0-262-19583-6&amp;rft.aulast=Stenning&amp;rft.aufirst=Keith&amp;rft.au=van+Lambalgen%2C+Michiel&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Fhumanreasoni_sten_2008_000_10735669&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span><a rel="nofollow" class="external free" href="https://philpapers.org/archive/STEHRA-5.pdf">https://philpapers.org/archive/STEHRA-5.pdf</a></span>
</li>
<li id="cite_note-46"><span class="mw-cite-backlink"><b><a href="#cite_ref-46">^</a></b></span> <span class="reference-text">Van Lambalgen, M. and Hamm, F., 2008. The proper treatment of events. John Wiley &amp; Sons.
<a rel="nofollow" class="external free" href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=3126320bb6e37ca3727fed404828b53fc56ff063">https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=3126320bb6e37ca3727fed404828b53fc56ff063</a></span>
</li>
<li id="cite_note-47"><span class="mw-cite-backlink"><b><a href="#cite_ref-47">^</a></b></span> <span class="reference-text">Reiter, R., 1991. The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. Artificial and Mathematical Theory of Computation, 3.</span>
</li>
<li id="cite_note-48"><span class="mw-cite-backlink"><b><a href="#cite_ref-48">^</a></b></span> <span class="reference-text">Merritt, D., 2012. Building expert systems in Prolog. Springer Science &amp; Business Media. <a rel="nofollow" class="external free" href="https://ds.amu.edu.et/xmlui/bitstream/handle/123456789/4434/%28Text%20Book%29%20Building%20Expert%20Systems%20in%20Prolog.pdf?sequence=1&amp;isAllowed=y">https://ds.amu.edu.et/xmlui/bitstream/handle/123456789/4434/%28Text%20Book%29%20Building%20Expert%20Systems%20in%20Prolog.pdf?sequence=1&amp;isAllowed=y</a></span>
</li>
<li id="cite_note-49"><span class="mw-cite-backlink"><b><a href="#cite_ref-49">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFSergotSadriKowalskiKriwaczek1986" class="citation journal cs1">Sergot, M.J.; Sadri, F.; Kowalski, R.A.; Kriwaczek, F.; Hammond, P; Cory, H.T. (1986). <a rel="nofollow" class="external text" href="http://www.doc.ic.ac.uk/~rak/papers/British%20Nationality%20Act.pdf">"The British Nationality Act as a logic program"</a> <span class="cs1-format">(PDF)</span>. <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i>. <b>29</b> (5): <span class="nowrap">370–</span>386. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F5689.5920">10.1145/5689.5920</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:5665107">5665107</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=The+British+Nationality+Act+as+a+logic+program&amp;rft.volume=29&amp;rft.issue=5&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E370-%3C%2Fspan%3E386&amp;rft.date=1986&amp;rft_id=info%3Adoi%2F10.1145%2F5689.5920&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A5665107%23id-name%3DS2CID&amp;rft.aulast=Sergot&amp;rft.aufirst=M.J.&amp;rft.au=Sadri%2C+F.&amp;rft.au=Kowalski%2C+R.A.&amp;rft.au=Kriwaczek%2C+F.&amp;rft.au=Hammond%2C+P&amp;rft.au=Cory%2C+H.T.&amp;rft_id=http%3A%2F%2Fwww.doc.ic.ac.uk%2F~rak%2Fpapers%2FBritish%2520Nationality%2520Act.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-50"><span class="mw-cite-backlink"><b><a href="#cite_ref-50">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFPrakkenSartor2015" class="citation journal cs1">Prakken, H.; Sartor, G. (October 2015). <a rel="nofollow" class="external text" href="https://www.sciencedirect.com/science/article/pii/S0004370215000910/pdfft?md5=4dc0cf07e5c2a6926d285431b987a859&amp;pid=1-s2.0-S0004370215000910-main.pdf">"Law and logic: a review from an argumentation perspective"</a> <span class="cs1-format">(PDF)</span>. <i><a href="/wiki/Artificial_Intelligence_(journal)" title="Artificial Intelligence (journal)">Artificial Intelligence</a></i>. <b>227</b>: <span class="nowrap">214–</span>245. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1016%2Fj.artint.2015.06.005">10.1016/j.artint.2015.06.005</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:4261497">4261497</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.atitle=Law+and+logic%3A+a+review+from+an+argumentation+perspective&amp;rft.volume=227&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E214-%3C%2Fspan%3E245&amp;rft.date=2015-10&amp;rft_id=info%3Adoi%2F10.1016%2Fj.artint.2015.06.005&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A4261497%23id-name%3DS2CID&amp;rft.aulast=Prakken&amp;rft.aufirst=H.&amp;rft.au=Sartor%2C+G.&amp;rft_id=https%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2FS0004370215000910%2Fpdfft%3Fmd5%3D4dc0cf07e5c2a6926d285431b987a859%26pid%3D1-s2.0-S0004370215000910-main.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-51"><span class="mw-cite-backlink"><b><a href="#cite_ref-51">^</a></b></span> <span class="reference-text">Satoh, K., 2023. PROLEG: Practical legal reasoning system. In Prolog: The Next 50 Years (pp. 277-283). Cham: Springer Nature Switzerland.</span>
</li>
<li id="cite_note-:02-52"><span class="mw-cite-backlink">^ <a href="#cite_ref-:02_52-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-:02_52-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKörnerLeuschelBarbosaCosta2022" class="citation journal cs1">Körner, Philipp; Leuschel, Michael; Barbosa, João; Costa, Vítor Santos; Dahl, Verónica; Hermenegildo, Manuel V.; Morales, Jose F.; Wielemaker, Jan; Diaz, Daniel; Abreu, Salvador; Ciatto, Giovanni (November 2022). <a rel="nofollow" class="external text" href="https://doi.org/10.1017%2FS1471068422000102">"Fifty Years of Prolog and Beyond"</a>. <i>Theory and Practice of Logic Programming</i>. <b>22</b> (6): <span class="nowrap">776–</span>858. <a href="/wiki/ArXiv_(identifier)" class="mw-redirect" title="ArXiv (identifier)">arXiv</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://arxiv.org/abs/2201.10816">2201.10816</a></span>. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1017%2FS1471068422000102">10.1017/S1471068422000102</a></span>. <a href="/wiki/ISSN_(identifier)" class="mw-redirect" title="ISSN (identifier)">ISSN</a>&#160;<a rel="nofollow" class="external text" href="https://search.worldcat.org/issn/1471-0684">1471-0684</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theory+and+Practice+of+Logic+Programming&amp;rft.atitle=Fifty+Years+of+Prolog+and+Beyond&amp;rft.volume=22&amp;rft.issue=6&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E776-%3C%2Fspan%3E858&amp;rft.date=2022-11&amp;rft_id=info%3Aarxiv%2F2201.10816&amp;rft.issn=1471-0684&amp;rft_id=info%3Adoi%2F10.1017%2FS1471068422000102&amp;rft.aulast=K%C3%B6rner&amp;rft.aufirst=Philipp&amp;rft.au=Leuschel%2C+Michael&amp;rft.au=Barbosa%2C+Jo%C3%A3o&amp;rft.au=Costa%2C+V%C3%ADtor+Santos&amp;rft.au=Dahl%2C+Ver%C3%B3nica&amp;rft.au=Hermenegildo%2C+Manuel+V.&amp;rft.au=Morales%2C+Jose+F.&amp;rft.au=Wielemaker%2C+Jan&amp;rft.au=Diaz%2C+Daniel&amp;rft.au=Abreu%2C+Salvador&amp;rft.au=Ciatto%2C+Giovanni&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1017%252FS1471068422000102&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-TL-53"><span class="mw-cite-backlink">^ <a href="#cite_ref-TL_53-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-TL_53-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Bonner, A.J. and Kifer, M., 1993, February. Transaction Logic Programming. In ICLP (Vol. 93, pp. 257-279).</span>
</li>
<li id="cite_note-54"><span class="mw-cite-backlink"><b><a href="#cite_ref-54">^</a></b></span> <span class="reference-text">Genesereth, M., 2023. Dynamic logic programming. In Prolog: The Next 50 Years (pp. 197-209). Cham: Springer Nature Switzerland.</span>
</li>
<li id="cite_note-55"><span class="mw-cite-backlink"><b><a href="#cite_ref-55">^</a></b></span> <span class="reference-text">Kowalski, R., Sadri, F., Calejo, M. and Dávila, J., 2023. Combining logic programming and imperative programming in LPS. In Prolog: The Next 50 Years (pp. 210-223). Cham: Springer Nature Switzerland.</span>
</li>
<li id="cite_note-56"><span class="mw-cite-backlink"><b><a href="#cite_ref-56">^</a></b></span> <span class="reference-text">Aho, A.V. and Ullman, J.D., 1979, January. Universality of data retrieval languages. In Proceedings of the 6th ACM SIGACT-SIGPLAN symposium on Principles of programming languages (pp. 110-119).</span>
</li>
<li id="cite_note-57"><span class="mw-cite-backlink"><b><a href="#cite_ref-57">^</a></b></span> <span class="reference-text">Maier, D., Tekle, K.T., Kifer, M. and Warren, D.S., 2018. Datalog: concepts, history, and outlook. In Declarative Logic Programming: Theory, Systems, and Applications (pp. 3-100).</span>
</li>
<li id="cite_note-58"><span class="mw-cite-backlink"><b><a href="#cite_ref-58">^</a></b></span> <span class="reference-text">Eiter, T., Ianni, G. and Krennwallner, T., 2009. Answer Set Programming: A Primer. In Reasoning Web. Semantic Technologies for Information Systems: 5th International Summer School 2009, Brixen-Bressanone, Italy, August 30-September 4, 2009, Tutorial Lectures (pp. 40-110).</span>
</li>
<li id="cite_note-59"><span class="mw-cite-backlink"><b><a href="#cite_ref-59">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFAriasCarroSalazarMarple2018" class="citation journal cs1">Arias, J.; Carro, M.; Salazar, E.; Marple, K.; Gupta, G. (2018). <a rel="nofollow" class="external text" href="https://doi.org/10.1017%2FS1471068418000285">"Constraint Answer Set Programming without Grounding"</a>. <i>Theory and Practice of Logic Programming</i>. <b>18</b> (<span class="nowrap">3–</span>4): <span class="nowrap">337–</span>354. <a href="/wiki/ArXiv_(identifier)" class="mw-redirect" title="ArXiv (identifier)">arXiv</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://arxiv.org/abs/1804.11162">1804.11162</a></span>. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1017%2FS1471068418000285">10.1017/S1471068418000285</a></span>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:13754645">13754645</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theory+and+Practice+of+Logic+Programming&amp;rft.atitle=Constraint+Answer+Set+Programming+without+Grounding&amp;rft.volume=18&amp;rft.issue=%3Cspan+class%3D%22nowrap%22%3E3%E2%80%93%3C%2Fspan%3E4&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E337-%3C%2Fspan%3E354&amp;rft.date=2018&amp;rft_id=info%3Aarxiv%2F1804.11162&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A13754645%23id-name%3DS2CID&amp;rft_id=info%3Adoi%2F10.1017%2FS1471068418000285&amp;rft.aulast=Arias&amp;rft.aufirst=J.&amp;rft.au=Carro%2C+M.&amp;rft.au=Salazar%2C+E.&amp;rft.au=Marple%2C+K.&amp;rft.au=Gupta%2C+G.&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1017%252FS1471068418000285&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-60"><span class="mw-cite-backlink"><b><a href="#cite_ref-60">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFDeneckerKakas2000" class="citation journal cs1">Denecker, M.; Kakas, A.C. (July 2000). <a rel="nofollow" class="external text" href="https://doi.org/10.1016%2FS0743-1066%2899%2900078-3">"Special issue: abductive logic programming"</a>. <i>Journal of Logic Programming</i>. <b>44</b> (<span class="nowrap">1–</span>3): <span class="nowrap">1–</span>4. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1016%2FS0743-1066%2899%2900078-3">10.1016/S0743-1066(99)00078-3</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+Logic+Programming&amp;rft.atitle=Special+issue%3A+abductive+logic+programming&amp;rft.volume=44&amp;rft.issue=%3Cspan+class%3D%22nowrap%22%3E1%E2%80%93%3C%2Fspan%3E3&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E1-%3C%2Fspan%3E4&amp;rft.date=2000-07&amp;rft_id=info%3Adoi%2F10.1016%2FS0743-1066%2899%2900078-3&amp;rft.aulast=Denecker&amp;rft.aufirst=M.&amp;rft.au=Kakas%2C+A.C.&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1016%252FS0743-1066%252899%252900078-3&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-61"><span class="mw-cite-backlink"><b><a href="#cite_ref-61">^</a></b></span> <span class="reference-text">Eshghi, K., 1988, August. Abductive Planning with Event Calculus. In ICLP/SLP (pp. 562-579).</span>
</li>
<li id="cite_note-62"><span class="mw-cite-backlink"><b><a href="#cite_ref-62">^</a></b></span> <span class="reference-text">Eshghi, K. and Kowalski, R.A., 1989, June. Abduction Compared with Negation by Failure. In ICLP (Vol. 89, pp. 234-255).</span>
</li>
<li id="cite_note-63"><span class="mw-cite-backlink"><b><a href="#cite_ref-63">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFNienhuys-ChengWolf1997" class="citation book cs1">Nienhuys-Cheng, Shan-hwei; Wolf, Ronald de (1997). <i>Foundations of inductive logic programming</i>. Lecture notes in computer science Lecture notes in artificial intelligence. Berlin Heidelberg: Springer. p.&#160;173. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-3-540-62927-6" title="Special:BookSources/978-3-540-62927-6"><bdi>978-3-540-62927-6</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Foundations+of+inductive+logic+programming&amp;rft.place=Berlin+Heidelberg&amp;rft.series=Lecture+notes+in+computer+science+Lecture+notes+in+artificial+intelligence&amp;rft.pages=173&amp;rft.pub=Springer&amp;rft.date=1997&amp;rft.isbn=978-3-540-62927-6&amp;rft.aulast=Nienhuys-Cheng&amp;rft.aufirst=Shan-hwei&amp;rft.au=Wolf%2C+Ronald+de&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-64"><span class="mw-cite-backlink"><b><a href="#cite_ref-64">^</a></b></span> <span class="reference-text">Flach, P.A. and Kakas, A.C., 2000. On the relation between abduction and inductive learning. In Abductive Reasoning and Learning (pp. 1-33). Dordrecht: Springer Netherlands.</span>
</li>
<li id="cite_note-65"><span class="mw-cite-backlink"><b><a href="#cite_ref-65">^</a></b></span> <span class="reference-text">Cropper, A. and Dumančić, S., 2022. Inductive logic programming at 30: a new introduction. Journal of Artificial Intelligence Research, 74, pp.765-850.</span>
</li>
<li id="cite_note-66"><span class="mw-cite-backlink"><b><a href="#cite_ref-66">^</a></b></span> <span class="reference-text">Russell, S., 2019. Human compatible: Artificial intelligence and the problem of control. Penguin.</span>
</li>
<li id="cite_note-67"><span class="mw-cite-backlink"><b><a href="#cite_ref-67">^</a></b></span> <span class="reference-text">Shunichi Uchida and Kazuhiro Fuchi. <i>Proceedings of the FGCS Project Evaluation Workshop</i>. Institute for New Generation Computer Technology (ICOT). 1992.</span>
</li>
<li id="cite_note-Hewitt-68"><span class="mw-cite-backlink"><b><a href="#cite_ref-Hewitt_68-0">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFHewitt,_Carl2016" class="citation web cs1">Hewitt, Carl (27 April 2016). <a rel="nofollow" class="external text" href="https://hal.archives-ouvertes.fr/hal-01148496v6/document">"Inconsistency Robustness for Logic Programs"</a>. Hal Archives. pp.&#160;<span class="nowrap">21–</span>26<span class="reference-accessdate">. Retrieved <span class="nowrap">7 November</span> 2016</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Inconsistency+Robustness+for+Logic+Programs&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E21-%3C%2Fspan%3E26&amp;rft.pub=Hal+Archives&amp;rft.date=2016-04-27&amp;rft.au=Hewitt%2C+Carl&amp;rft_id=https%3A%2F%2Fhal.archives-ouvertes.fr%2Fhal-01148496v6%2Fdocument&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-69"><span class="mw-cite-backlink"><b><a href="#cite_ref-69">^</a></b></span> <span class="reference-text">Saraswat, V.A. and Rinard, M., 1989, December. Concurrent constraint programming. In Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (pp. 232-245).</span>
</li>
<li id="cite_note-hilog-jlp-70"><span class="mw-cite-backlink"><b><a href="#cite_ref-hilog-jlp_70-0">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFChenKiferWarren1993" class="citation journal cs1">Chen, Weidong; Kifer, Michael; Warren, David S. (February 1993). <a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0743-1066%2893%2990039-J">"HiLog: A foundation for higher-order logic programming"</a>. <i><a href="/wiki/Journal_of_Logic_Programming" class="mw-redirect" title="Journal of Logic Programming">Journal of Logic Programming</a></i>. <b>15</b> (3): <span class="nowrap">187–</span>230. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0743-1066%2893%2990039-J">10.1016/0743-1066(93)90039-J</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+Logic+Programming&amp;rft.atitle=HiLog%3A+A+foundation+for+higher-order+logic+programming&amp;rft.volume=15&amp;rft.issue=3&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E187-%3C%2Fspan%3E230&amp;rft.date=1993-02&amp;rft_id=info%3Adoi%2F10.1016%2F0743-1066%2893%2990039-J&amp;rft.aulast=Chen&amp;rft.aufirst=Weidong&amp;rft.au=Kifer%2C+Michael&amp;rft.au=Warren%2C+David+S.&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1016%252F0743-1066%252893%252990039-J&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-71"><span class="mw-cite-backlink"><b><a href="#cite_ref-71">^</a></b></span> <span class="reference-text">Miller, D.A. and Nadathur, G., 1986, July. Higher-order logic programming. In International Conference on Logic Programming (pp. 448-462). Berlin, Heidelberg: Springer Berlin Heidelberg.</span>
</li>
<li id="cite_note-72"><span class="mw-cite-backlink"><b><a href="#cite_ref-72">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFAndreoli1992" class="citation journal cs1">Andreoli, Jean-Marc (1 June 1992). "Logic Programming with Focusing Proofs in Linear Logic". <i><a href="/wiki/Journal_of_Logic_and_Computation" title="Journal of Logic and Computation">Journal of Logic and Computation</a></i>. <b>2</b> (3): <span class="nowrap">297–</span>347. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1093%2Flogcom%2F2.3.297">10.1093/logcom/2.3.297</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+Logic+and+Computation&amp;rft.atitle=Logic+Programming+with+Focusing+Proofs+in+Linear+Logic&amp;rft.volume=2&amp;rft.issue=3&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E297-%3C%2Fspan%3E347&amp;rft.date=1992-06-01&amp;rft_id=info%3Adoi%2F10.1093%2Flogcom%2F2.3.297&amp;rft.aulast=Andreoli&amp;rft.aufirst=Jean-Marc&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-73"><span class="mw-cite-backlink"><b><a href="#cite_ref-73">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFHodasMiller1994" class="citation journal cs1">Hodas, Joshua; Miller, Dale (1994). <a rel="nofollow" class="external text" href="http://repository.upenn.edu/cgi/viewcontent.cgi?article=1540&amp;context=cis_reports">"Logic Programming in a Fragment of Intuitionistic Linear Logic"</a>. <i><a href="/wiki/Information_and_Computation" title="Information and Computation">Information and Computation</a></i>. <b>110</b> (2): <span class="nowrap">327–</span>365. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1006%2Finco.1994.1036">10.1006/inco.1994.1036</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Information+and+Computation&amp;rft.atitle=Logic+Programming+in+a+Fragment+of+Intuitionistic+Linear+Logic&amp;rft.volume=110&amp;rft.issue=2&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E327-%3C%2Fspan%3E365&amp;rft.date=1994&amp;rft_id=info%3Adoi%2F10.1006%2Finco.1994.1036&amp;rft.aulast=Hodas&amp;rft.aufirst=Joshua&amp;rft.au=Miller%2C+Dale&amp;rft_id=http%3A%2F%2Frepository.upenn.edu%2Fcgi%2Fviewcontent.cgi%3Farticle%3D1540%26context%3Dcis_reports&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-74"><span class="mw-cite-backlink"><b><a href="#cite_ref-74">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKobayashiYonezawa1994" class="citation conference cs1">Kobayashi, Naoki; <a href="/wiki/Akinori_Yonezawa" title="Akinori Yonezawa">Yonezawa, Akinori</a> (1994). <i>Asynchronous communication model based on linear logic</i>. US/Japan Workshop on Parallel Symbolic Computing. pp.&#160;<span class="nowrap">279–</span>294. <a href="/wiki/CiteSeerX_(identifier)" class="mw-redirect" title="CiteSeerX (identifier)">CiteSeerX</a>&#160;<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.8749">10.1.1.42.8749</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=conference&amp;rft.btitle=Asynchronous+communication+model+based+on+linear+logic&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E279-%3C%2Fspan%3E294&amp;rft.date=1994&amp;rft_id=https%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.42.8749%23id-name%3DCiteSeerX&amp;rft.aulast=Kobayashi&amp;rft.aufirst=Naoki&amp;rft.au=Yonezawa%2C+Akinori&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-75"><span class="mw-cite-backlink"><b><a href="#cite_ref-75">^</a></b></span> <span class="reference-text"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFMiller1996" class="citation journal cs1">Miller, Dale (30 September 1996). <a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0304-3975%2896%2900045-X">"Forum: A Multiple-Conclusion Specification Logic"</a>. <i><a href="/wiki/Theoretical_Computer_Science_(journal)" title="Theoretical Computer Science (journal)">Theoretical Computer Science</a></i>. <b>165</b> (1): <span class="nowrap">201–</span>232. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0304-3975%2896%2900045-X">10.1016/0304-3975(96)00045-X</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theoretical+Computer+Science&amp;rft.atitle=Forum%3A+A+Multiple-Conclusion+Specification+Logic&amp;rft.volume=165&amp;rft.issue=1&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E201-%3C%2Fspan%3E232&amp;rft.date=1996-09-30&amp;rft_id=info%3Adoi%2F10.1016%2F0304-3975%2896%2900045-X&amp;rft.aulast=Miller&amp;rft.aufirst=Dale&amp;rft_id=https%3A%2F%2Fdoi.org%2F10.1016%252F0304-3975%252896%252900045-X&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></span>
</li>
<li id="cite_note-76"><span class="mw-cite-backlink"><b><a href="#cite_ref-76">^</a></b></span> <span class="reference-text">Kifer, M. and Lausen, G., 1989, June. F-logic: a higher-order language for reasoning about objects, inheritance, and scheme. In Proceedings of the 1989 ACM SIGMOD international conference on Management of data (pp. 134-146).</span>
</li>
<li id="cite_note-77"><span class="mw-cite-backlink"><b><a href="#cite_ref-77">^</a></b></span> <span class="reference-text">de Moura, P.J.L., 2003. Design of an Object-Oriented Logic Programming Language (Doctoral dissertation, Universidade da Beira Interior).</span>
</li>
<li id="cite_note-78"><span class="mw-cite-backlink"><b><a href="#cite_ref-78">^</a></b></span> <span class="reference-text">Yang, G. and Kifer, M., 2000, July. FLORA: Implementing an efficient DOOD system using a tabling logic engine. In International Conference on Computational Logic (pp. 1078-1093). Berlin, Heidelberg: Springer Berlin Heidelberg.</span>
</li>
</ol></div></div>
<div class="mw-heading mw-heading2"><h2 id="Sources">Sources</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=26" title="Edit section: Sources"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<div class="mw-heading mw-heading3"><h3 id="General_introductions">General introductions</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=27" title="Edit section: General introductions"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<ul><li><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFBaralGelfond1994" class="citation journal cs1 cs1-prop-long-vol">Baral, C.; Gelfond, M. (1994). <a rel="nofollow" class="external text" href="http://redwood.cs.ttu.edu/~mgelfond/PAPERS/survey.pdf">"Logic programming and knowledge representation"</a> <span class="cs1-format">(PDF)</span>. <i>The Journal of Logic Programming</i>. <span class="nowrap">19–</span>20: <span class="nowrap">73–</span>148. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0743-1066%2894%2990025-6">10.1016/0743-1066(94)90025-6</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.atitle=Logic+programming+and+knowledge+representation&amp;rft.volume=19%E2%80%9320&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E73-%3C%2Fspan%3E148&amp;rft.date=1994&amp;rft_id=info%3Adoi%2F10.1016%2F0743-1066%2894%2990025-6&amp;rft.aulast=Baral&amp;rft.aufirst=C.&amp;rft.au=Gelfond%2C+M.&amp;rft_id=http%3A%2F%2Fredwood.cs.ttu.edu%2F~mgelfond%2FPAPERS%2Fsurvey.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></li>
<li><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFKowalski1988" class="citation journal cs1">Kowalski, R. A. (1988). <a rel="nofollow" class="external text" href="http://www.doc.ic.ac.uk/~rak/papers/the%20early%20years.pdf">"The early years of logic programming"</a> <span class="cs1-format">(PDF)</span>. <i>Communications of the ACM</i>. <b>31</b>: <span class="nowrap">38–</span>43. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1145%2F35043.35046">10.1145/35043.35046</a>. <a href="/wiki/S2CID_(identifier)" class="mw-redirect" title="S2CID (identifier)">S2CID</a>&#160;<a rel="nofollow" class="external text" href="https://api.semanticscholar.org/CorpusID:12259230">12259230</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=The+early+years+of+logic+programming&amp;rft.volume=31&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E38-%3C%2Fspan%3E43&amp;rft.date=1988&amp;rft_id=info%3Adoi%2F10.1145%2F35043.35046&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A12259230%23id-name%3DS2CID&amp;rft.aulast=Kowalski&amp;rft.aufirst=R.+A.&amp;rft_id=http%3A%2F%2Fwww.doc.ic.ac.uk%2F~rak%2Fpapers%2Fthe%2520early%2520years.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span> <a rel="nofollow" class="external autonumber" href="http://www.doc.ic.ac.uk/~rak/papers/the%20early%20years.pdf">[1]</a></li>
<li><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFLloyd1987" class="citation book cs1">Lloyd, J. W. (1987). <i>Foundations of Logic Programming</i> (2nd&#160;ed.). Springer-Verlag.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Foundations+of+Logic+Programming&amp;rft.edition=2nd&amp;rft.pub=Springer-Verlag&amp;rft.date=1987&amp;rft.aulast=Lloyd&amp;rft.aufirst=J.+W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></li></ul>
<div class="mw-heading mw-heading3"><h3 id="Other_sources">Other sources</h3><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=28" title="Edit section: Other sources"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<ul><li>John McCarthy. <a rel="nofollow" class="external text" href="http://www.cs.rit.edu/~rlaz/is2014/files/McCarthyProgramsWithCommonSense.pdf">"Programs with common sense"</a>. <i>Symposium on Mechanization of Thought Processes</i>. National Physical Laboratory. Teddington, England. 1958.</li>
<li><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1238218222"><cite id="CITEREFMillerNadathurPfenningScedrov1991" class="citation journal cs1">Miller, Dale; Nadathur, Gopalan; Pfenning, Frank; Scedrov, Andre (1991). <a rel="nofollow" class="external text" href="https://repository.upenn.edu/cis_reports/711">"Uniform proofs as a foundation for logic programming"</a>. <i>Annals of Pure and Applied Logic</i>. <b>51</b> (<span class="nowrap">1–</span>2): <span class="nowrap">125–</span>157. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<span class="id-lock-free" title="Freely accessible"><a rel="nofollow" class="external text" href="https://doi.org/10.1016%2F0168-0072%2891%2990068-W">10.1016/0168-0072(91)90068-W</a></span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Annals+of+Pure+and+Applied+Logic&amp;rft.atitle=Uniform+proofs+as+a+foundation+for+logic+programming&amp;rft.volume=51&amp;rft.issue=%3Cspan+class%3D%22nowrap%22%3E1%E2%80%93%3C%2Fspan%3E2&amp;rft.pages=%3Cspan+class%3D%22nowrap%22%3E125-%3C%2Fspan%3E157&amp;rft.date=1991&amp;rft_id=info%3Adoi%2F10.1016%2F0168-0072%2891%2990068-W&amp;rft.aulast=Miller&amp;rft.aufirst=Dale&amp;rft.au=Nadathur%2C+Gopalan&amp;rft.au=Pfenning%2C+Frank&amp;rft.au=Scedrov%2C+Andre&amp;rft_id=https%3A%2F%2Frepository.upenn.edu%2Fcis_reports%2F711&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALogic+programming" class="Z3988"></span></li>
<li>Ehud Shapiro (Editor). <i>Concurrent Prolog</i>. MIT Press. 1987.</li>
<li>James Slagle. <a rel="nofollow" class="external text" href="https://dl.acm.org/doi/abs/10.1145/365691.365960">"Experiments with a Deductive Question-Answering Program"</a>. CACM. December 1965.</li>
<li><a href="/wiki/Dov_Gabbay" title="Dov Gabbay">Gabbay, Dov M.</a>; Hogger, Christopher John; Robinson, J.A., eds. (1993-1998). <a rel="nofollow" class="external text" href="https://www.worldcat.org/oclc/26300491">Handbook of Logic in Artificial Intelligence and Logic Programming</a>.Vols. 1–5, Oxford University Press.</li></ul>
<div class="mw-heading mw-heading2"><h2 id="Further_reading">Further reading</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=29" title="Edit section: Further reading"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<ul><li>Carl Hewitt. "<a rel="nofollow" class="external text" href="https://www.ijcai.org/Proceedings/71/Papers/014%20A.pdf">Procedural Embedding of Knowledge in Planner</a>". IJCAI 1971.</li>
<li>Carl Hewitt. "<a rel="nofollow" class="external text" href="https://web.archive.org/web/20170102172145/https://pdfs.semanticscholar.org/9993/ec68770faaab132da6945492b0e4ad07eb7b.pdf">The Repeated Demise of Logic Programming and Why It Will Be Reincarnated</a>". <i>AAAI Spring Symposium: What Went Wrong and Why: Lessons from AI Research and Applications</i> 2006: 2–9.</li>
<li>Evgeny Dantsin, Thomas Eiter, Georg Gottlob, Andrei Voronkov: <a rel="nofollow" class="external text" href="http://cmpe.emu.edu.tr/bayram/courses/531/forpresentation/p374-dantsin.pdf">Complexity and expressive power of logic programming</a>. ACM Comput. Surv. 33(3): 374–425 (2001)</li>
<li>Ulf Nilsson and Jan Maluszynski, <a rel="nofollow" class="external text" href="http://www.ida.liu.se/~ulfni/lpp/">Logic, Programming and Prolog</a></li></ul>
<div class="mw-heading mw-heading2"><h2 id="External_links">External links</h2><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Logic_programming&amp;action=edit&amp;section=30" title="Edit section: External links"><span>edit</span></a><span class="mw-editsection-bracket">]</span></span></div>
<style data-mw-deduplicate="TemplateStyles:r1235681985">.mw-parser-output .side-box{margin:4px 0;box-sizing:border-box;border:1px solid #aaa;font-size:88%;line-height:1.25em;background-color:var(--background-color-interactive-subtle,#f8f9fa);display:flow-root}.mw-parser-output .side-box-abovebelow,.mw-parser-output .side-box-text{padding:0.25em 0.9em}.mw-parser-output .side-box-image{padding:2px 0 2px 0.9em;text-align:center}.mw-parser-output .side-box-imageright{padding:2px 0.9em 2px 0;text-align:center}@media(min-width:500px){.mw-parser-output .side-box-flex{display:flex;align-items:center}.mw-parser-output .side-box-text{flex:1;min-width:0}}@media(min-width:720px){.mw-parser-output .side-box{width:238px}.mw-parser-output .side-box-right{clear:right;float:right;margin-left:1em}.mw-parser-output .side-box-left{margin-right:1em}}</style><style data-mw-deduplicate="TemplateStyles:r1237033735">@media print{body.ns-0 .mw-parser-output .sistersitebox{display:none!important}}@media screen{html.skin-theme-clientpref-night .mw-parser-output .sistersitebox img[src*="Wiktionary-logo-en-v2.svg"]{background-color:white}}@media screen and (prefers-color-scheme:dark){html.skin-theme-clientpref-os .mw-parser-output .sistersitebox img[src*="Wiktionary-logo-en-v2.svg"]{background-color:white}}</style><div class="side-box side-box-right plainlinks sistersitebox"><style data-mw-deduplicate="TemplateStyles:r1126788409">.mw-parser-output .plainlist ol,.mw-parser-output .plainlist ul{line-height:inherit;list-style:none;margin:0;padding:0}.mw-parser-output .plainlist ol li,.mw-parser-output .plainlist ul li{margin-bottom:0}</style>
<div class="side-box-flex">
<div class="side-box-image"><span class="noviewer" typeof="mw:File"><a href="/wiki/File:Commons-logo.svg" class="mw-file-description"><img alt="" src="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/30px-Commons-logo.svg.png" decoding="async" width="30" height="40" class="mw-file-element" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/45px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/59px-Commons-logo.svg.png 2x" data-file-width="1024" data-file-height="1376" /></a></span></div>
<div class="side-box-text plainlist">Wikimedia Commons has media related to <span style="font-weight: bold; font-style: italic;"><a href="https://commons.wikimedia.org/wiki/Category:Logic_programming" class="extiw" title="commons:Category:Logic programming">Logic programming</a></span>.</div></div>
</div>
<ul><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20050828194751/http://vl.fmnet.info/logic-prog/"><i>Logic Programming</i> Virtual Library entry</a></li>
<li><a rel="nofollow" class="external text" href="http://liinwww.ira.uka.de/bibliography/LogicProgramming/">Bibliographies on Logic Programming</a> <a rel="nofollow" class="external text" href="https://web.archive.org/web/20081204113711/http://liinwww.ira.uka.de/bibliography/LogicProgramming/">Archived</a> 2008-12-04 at the <a href="/wiki/Wayback_Machine" title="Wayback Machine">Wayback Machine</a></li>
<li><a rel="nofollow" class="external text" href="http://www.logicprogramming.org/">Association for Logic Programming (ALP)</a></li>
<li><i><a rel="nofollow" class="external text" href="http://www.cs.kuleuven.be/~dtai/projects/ALP/TPLP/">Theory and Practice of Logic Programming</a></i> (journal)</li>
<li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20090108012954/http://www.mpprogramming.com/Cpp/">Logic programming in C++ with Castor</a></li>
<li><a rel="nofollow" class="external text" href="http://www.mozart-oz.org/documentation/tutorial/node12.html">Logic programming</a> <a rel="nofollow" class="external text" href="https://web.archive.org/web/20110903022204/http://www.mozart-oz.org/documentation/tutorial/node12.html">Archived</a> 2011-09-03 at the <a href="/wiki/Wayback_Machine" title="Wayback Machine">Wayback Machine</a> in <a href="/wiki/Oz_programming_language" class="mw-redirect" title="Oz programming language">Oz</a></li>
<li><a rel="nofollow" class="external text" href="http://www.pdc.dk/">Prolog Development Center </a></li>
<li><a rel="nofollow" class="external text" href="http://docs.racket-lang.org/racklog/">Racklog: Logic Programming in Racket</a></li></ul>
<div class="navbox-styles"><style data-mw-deduplicate="TemplateStyles:r1129693374">.mw-parser-output .hlist dl,.mw-parser-output .hlist ol,.mw-parser-output .hlist ul{margin:0;padding:0}.mw-parser-output .hlist dd,.mw-parser-output .hlist dt,.mw-parser-output .hlist li{margin:0;display:inline}.mw-parser-output .hlist.inline,.mw-parser-output .hlist.inline dl,.mw-parser-output .hlist.inline ol,.mw-parser-output .hlist.inline ul,.mw-parser-output .hlist dl dl,.mw-parser-output .hlist dl ol,.mw-parser-output .hlist dl ul,.mw-parser-output .hlist ol dl,.mw-parser-output .hlist ol ol,.mw-parser-output .hlist ol ul,.mw-parser-output .hlist ul dl,.mw-parser-output .hlist ul ol,.mw-parser-output .hlist ul ul{display:inline}.mw-parser-output .hlist .mw-empty-li{display:none}.mw-parser-output .hlist dt::after{content:": "}.mw-parser-output .hlist dd::after,.mw-parser-output .hlist li::after{content:" · ";font-weight:bold}.mw-parser-output .hlist dd:last-child::after,.mw-parser-output .hlist dt:last-child::after,.mw-parser-output .hlist li:last-child::after{content:none}.mw-parser-output .hlist dd dd:first-child::before,.mw-parser-output .hlist dd dt:first-child::before,.mw-parser-output .hlist dd li:first-child::before,.mw-parser-output .hlist dt dd:first-child::before,.mw-parser-output .hlist dt dt:first-child::before,.mw-parser-output .hlist dt li:first-child::before,.mw-parser-output .hlist li dd:first-child::before,.mw-parser-output .hlist li dt:first-child::before,.mw-parser-output .hlist li li:first-child::before{content:" (";font-weight:normal}.mw-parser-output .hlist dd dd:last-child::after,.mw-parser-output .hlist dd dt:last-child::after,.mw-parser-output .hlist dd li:last-child::after,.mw-parser-output .hlist dt dd:last-child::after,.mw-parser-output .hlist dt dt:last-child::after,.mw-parser-output .hlist dt li:last-child::after,.mw-parser-output .hlist li dd:last-child::after,.mw-parser-output .hlist li dt:last-child::after,.mw-parser-output .hlist li li:last-child::after{content:")";font-weight:normal}.mw-parser-output .hlist ol{counter-reset:listitem}.mw-parser-output .hlist ol>li{counter-increment:listitem}.mw-parser-output .hlist ol>li::before{content:" "counter(listitem)"\a0 "}.mw-parser-output .hlist dd ol>li:first-child::before,.mw-parser-output .hlist dt ol>li:first-child::before,.mw-parser-output .hlist li ol>li:first-child::before{content:" ("counter(listitem)"\a0 "}</style><style data-mw-deduplicate="TemplateStyles:r1236075235">.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}body.skin--responsive .mw-parser-output .navbox-image img{max-width:none!important}@media print{body.ns-0 .mw-parser-output .navbox{display:none!important}}</style></div><div role="navigation" class="navbox" aria-labelledby="Programming_paradigms_(Comparison_by_language)" style="padding:3px"><table class="nowraplinks mw-collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1129693374"><style data-mw-deduplicate="TemplateStyles:r1239400231">.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}html.skin-theme-clientpref-night .mw-parser-output .navbar li a abbr{color:var(--color-base)!important}@media(prefers-color-scheme:dark){html.skin-theme-clientpref-os .mw-parser-output .navbar li a abbr{color:var(--color-base)!important}}@media print{.mw-parser-output .navbar{display:none!important}}</style><div class="navbar plainlinks hlist navbar-mini"><ul><li class="nv-view"><a href="/wiki/Template:Programming_paradigms_navbox" title="Template:Programming paradigms navbox"><abbr title="View this template">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:Programming_paradigms_navbox" title="Template talk:Programming paradigms navbox"><abbr title="Discuss this template">t</abbr></a></li><li class="nv-edit"><a href="/wiki/Special:EditPage/Template:Programming_paradigms_navbox" title="Special:EditPage/Template:Programming paradigms navbox"><abbr title="Edit this template">e</abbr></a></li></ul></div><div id="Programming_paradigms_(Comparison_by_language)" style="font-size:114%;margin:0 4em"><a href="/wiki/Programming_paradigm" title="Programming paradigm">Programming paradigms</a> (<a href="/wiki/Comparison_of_multi-paradigm_programming_languages" title="Comparison of multi-paradigm programming languages">Comparison by language</a>)</div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a></th><td class="navbox-list-with-group navbox-list navbox-odd hlist" style="width:100%;padding:0"><div style="padding:0 0.25em"></div><table class="nowraplinks navbox-subgroup" style="border-spacing:0"><tbody><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Structured_programming" title="Structured programming">Structured</a></th><td class="navbox-list-with-group navbox-list navbox-odd" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Jackson_structured_programming" title="Jackson structured programming">Jackson structures</a></li>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a></li>
<li><a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a></li>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
<li><a href="/wiki/Programming_in_the_large_and_programming_in_the_small" title="Programming in the large and programming in the small">Programming in the large and in the small</a></li>
<li><a href="/wiki/Design_by_contract" title="Design by contract">Design by contract</a></li>
<li><a href="/wiki/Invariant-based_programming" title="Invariant-based programming">Invariant-based</a></li>
<li><a href="/wiki/Nested_function" title="Nested function">Nested function</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented</a><br />(<a href="/wiki/Comparison_of_programming_languages_(object-oriented_programming)" title="Comparison of programming languages (object-oriented programming)">comparison</a>, <a href="/wiki/List_of_object-oriented_programming_languages" title="List of object-oriented programming languages">list</a>)</th><td class="navbox-list-with-group navbox-list navbox-even" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a>, <a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a>, <a href="/wiki/Object-based_language" title="Object-based language">Object-based</a></li>
<li><a href="/wiki/Agent-oriented_programming" title="Agent-oriented programming">Agent</a></li>
<li><a href="/wiki/Immutable_object" title="Immutable object">Immutable object</a></li>
<li><a href="/wiki/Persistent_programming_language" title="Persistent programming language">Persistent</a></li>
<li><a href="/wiki/Uniform_Function_Call_Syntax" title="Uniform Function Call Syntax">Uniform Function Call Syntax</a></li></ul>
</div></td></tr></tbody></table><div></div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a></th><td class="navbox-list-with-group navbox-list navbox-odd hlist" style="width:100%;padding:0"><div style="padding:0 0.25em"></div><table class="nowraplinks navbox-subgroup" style="border-spacing:0"><tbody><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Functional_programming" title="Functional programming">Functional</a><br />(<a href="/wiki/Comparison_of_functional_programming_languages" title="Comparison of functional programming languages">comparison</a>)</th><td class="navbox-list-with-group navbox-list navbox-odd" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
<li><a href="/wiki/Anonymous_function" title="Anonymous function">Anonymous function</a> (<a href="/wiki/Partial_application" title="Partial application">Partial application</a>)</li>
<li><a href="/wiki/Higher-order_programming" title="Higher-order programming">Higher-order</a></li>
<li><a href="/wiki/Purely_functional_programming" title="Purely functional programming">Purely functional</a></li>
<li><a href="/wiki/Total_functional_programming" title="Total functional programming">Total</a></li>
<li><a href="/wiki/Strict_programming_language" title="Strict programming language">Strict</a></li>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">GADTs</a></li>
<li><a href="/wiki/Dependent_type" title="Dependent type">Dependent types</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Tacit_programming" title="Tacit programming">Point-free style</a></li>
<li><a href="/wiki/Expression-oriented_programming_language" title="Expression-oriented programming language">Expression-oriented</a></li>
<li><a href="/wiki/Applicative_programming_language" title="Applicative programming language">Applicative</a>, <a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
<li><a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a>, <a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a></th><td class="navbox-list-with-group navbox-list navbox-even" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a> (<a href="/wiki/Functional_reactive_programming" title="Functional reactive programming">Functional reactive</a>)</li>
<li><a href="/wiki/Signal_programming" class="mw-redirect" title="Signal programming">Signals</a></li>
<li><a href="/wiki/Stream_processing" title="Stream processing">Streams</a></li>
<li><a href="/wiki/Synchronous_programming_language" title="Synchronous programming language">Synchronous</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a class="mw-selflink selflink">Logic</a></th><td class="navbox-list-with-group navbox-list navbox-odd" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a> (<a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a>)</li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
<li><a href="/wiki/Nondeterministic_programming" title="Nondeterministic programming">Nondeterministic</a></li>
<li><a href="/wiki/Ontology_language" title="Ontology language">Ontology</a></li>
<li><a href="/wiki/Probabilistic_logic_programming" title="Probabilistic logic programming">Probabilistic logic</a></li>
<li><a href="/wiki/Query_language" title="Query language">Query</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Domain-specific_language" title="Domain-specific language">DSL</a></th><td class="navbox-list-with-group navbox-list navbox-even" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Algebraic_modeling_language" title="Algebraic modeling language">Algebraic modeling</a></li>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
<li><a href="/wiki/Automata-based_programming" title="Automata-based programming">Automata-based</a> (<a href="/wiki/Action_language" title="Action language">Action</a>)</li>
<li><a href="/wiki/Command_language" title="Command language">Command</a> (<a href="/wiki/Spacecraft_command_language" title="Spacecraft command language">Spacecraft</a>)</li>
<li><a href="/wiki/Differentiable_programming" title="Differentiable programming">Differentiable</a></li>
<li><a href="/wiki/End-user_development" title="End-user development">End-user</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a></li>
<li><a href="/wiki/Interface_description_language" title="Interface description language">Interface description</a></li>
<li><a href="/wiki/Language-oriented_programming" title="Language-oriented programming">Language-oriented</a></li>
<li><a href="/wiki/List_comprehension" title="List comprehension">List comprehension</a></li>
<li><a href="/wiki/Low-code_development_platform" title="Low-code development platform">Low-code</a></li>
<li><a href="/wiki/Modeling_language" title="Modeling language">Modeling</a></li>
<li><a href="/wiki/Natural-language_programming" title="Natural-language programming">Natural language</a></li>
<li><a href="/wiki/Non-English-based_programming_languages" title="Non-English-based programming languages">Non-English-based</a></li>
<li><a href="/wiki/Page_description_language" title="Page description language">Page description</a></li>
<li><a href="/wiki/Pipeline_(software)" title="Pipeline (software)">Pipes</a> and <a href="/wiki/Filter_(software)" title="Filter (software)">filters</a></li>
<li><a href="/wiki/Probabilistic_programming" title="Probabilistic programming">Probabilistic</a></li>
<li><a href="/wiki/Quantum_programming" title="Quantum programming">Quantum</a></li>
<li><a href="/wiki/Scientific_programming_language" title="Scientific programming language">Scientific</a></li>
<li><a href="/wiki/Scripting_language" title="Scripting language">Scripting</a></li>
<li><a href="/wiki/Set_theoretic_programming" title="Set theoretic programming">Set-theoretic</a></li>
<li><a href="/wiki/Simulation_language" title="Simulation language">Simulation</a></li>
<li><a href="/wiki/Stack-oriented_programming" title="Stack-oriented programming">Stack-based</a></li>
<li><a href="/wiki/System_programming_language" title="System programming language">System</a></li>
<li><a href="/wiki/Tactile_programming_language" title="Tactile programming language">Tactile</a></li>
<li><a href="/wiki/Template_processor" title="Template processor">Templating</a></li>
<li><a href="/wiki/Transformation_language" title="Transformation language">Transformation</a> (<a href="/wiki/Graph_rewriting" title="Graph rewriting">Graph rewriting</a>, <a href="/wiki/Production_system_(computer_science)" title="Production system (computer science)">Production</a>, <a href="/wiki/Pattern_matching" title="Pattern matching">Pattern</a>)</li>
<li><a href="/wiki/Visual_programming_language" title="Visual programming language">Visual</a></li></ul>
</div></td></tr></tbody></table><div></div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Concurrent_computing" title="Concurrent computing">Concurrent</a>,<br /><a href="/wiki/Distributed_computing" title="Distributed computing">distributed</a>,<br /><a href="/wiki/Parallel_computing" title="Parallel computing">parallel</a></th><td class="navbox-list-with-group navbox-list navbox-odd hlist" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Actor_model" title="Actor model">Actor-based</a></li>
<li><a href="/wiki/Automatic_mutual_exclusion" title="Automatic mutual exclusion">Automatic mutual exclusion</a></li>
<li><a href="/wiki/Choreographic_programming" title="Choreographic programming">Choreographic programming</a></li>
<li><a href="/wiki/Concurrent_logic_programming" title="Concurrent logic programming">Concurrent logic</a> (<a href="/wiki/Concurrent_constraint_logic_programming" title="Concurrent constraint logic programming">Concurrent constraint logic</a>)</li>
<li><a href="/wiki/Concurrent_object-oriented_programming" title="Concurrent object-oriented programming">Concurrent OO</a></li>
<li><a href="/wiki/Macroprogramming" title="Macroprogramming">Macroprogramming</a></li>
<li><a href="/wiki/Multitier_programming" title="Multitier programming">Multitier programming</a></li>
<li><a href="/wiki/Organic_computing" title="Organic computing">Organic computing</a></li>
<li><a href="/wiki/Parallel_programming_model" title="Parallel programming model">Parallel programming models</a></li>
<li><a href="/wiki/Partitioned_global_address_space" title="Partitioned global address space">Partitioned global address space</a></li>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
<li><a href="/wiki/Service-oriented_programming" title="Service-oriented programming">Service-oriented</a></li>
<li><a href="/wiki/Structured_concurrency" title="Structured concurrency">Structured concurrency</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Metaprogramming" title="Metaprogramming">Metaprogramming</a></th><td class="navbox-list-with-group navbox-list navbox-even hlist" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a> (<a href="/wiki/Inductive_programming" title="Inductive programming">Inductive</a>)</li>
<li><a href="/wiki/Dynamic_programming_language" title="Dynamic programming language">Dynamic</a></li>
<li><a href="/wiki/Extensible_programming" title="Extensible programming">Extensible</a></li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconicity</a></li>
<li><a href="/wiki/Interactive_programming" title="Interactive programming">Interactive</a></li>
<li><a href="/wiki/Macro_(computer_science)" title="Macro (computer science)">Macro</a> (<a href="/wiki/Hygienic_macro" title="Hygienic macro">Hygienic</a>)</li>
<li><a href="/wiki/Metalinguistic_abstraction" title="Metalinguistic abstraction">Metalinguistic abstraction</a></li>
<li><a href="/wiki/Multi-stage_programming" title="Multi-stage programming">Multi-stage</a></li>
<li><a href="/wiki/Program_synthesis" title="Program synthesis">Program synthesis</a> (<a href="/wiki/Bayesian_program_synthesis" title="Bayesian program synthesis">Bayesian</a>, <a href="/wiki/Inferential_programming" title="Inferential programming">Inferential</a>, <a href="/wiki/Programming_by_demonstration" title="Programming by demonstration">by demonstration</a>, <a href="/wiki/Programming_by_example" title="Programming by example">by example</a>)</li>
<li><a href="/wiki/Reflective_programming" title="Reflective programming">Reflective</a></li>
<li><a href="/wiki/Self-modifying_code" title="Self-modifying code">Self-modifying code</a></li>
<li><a href="/wiki/Symbolic_programming" title="Symbolic programming">Symbolic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Separation_of_concerns" title="Separation of concerns">Separation<br />of concerns</a></th><td class="navbox-list-with-group navbox-list navbox-odd hlist" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspects</a></li>
<li><a href="/wiki/Component-based_software_engineering" title="Component-based software engineering">Components</a></li>
<li><a href="/wiki/Data-driven_programming" title="Data-driven programming">Data-driven</a></li>
<li><a href="/wiki/Data-oriented_design" title="Data-oriented design">Data-oriented</a></li>
<li><a href="/wiki/Event-driven_programming" title="Event-driven programming">Event-driven</a></li>
<li><a href="/wiki/Feature-oriented_programming" title="Feature-oriented programming">Features</a></li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
<li><a href="/wiki/Literate_programming" title="Literate programming">Literate</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Roles</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subjects</a></li></ul>
</div></td></tr></tbody></table></div>
<div class="navbox-styles"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1129693374"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236075235"></div><div role="navigation" class="navbox" aria-labelledby="Types_of_programming_languages" style="padding:3px"><table class="nowraplinks mw-collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1129693374"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1239400231"><div class="navbar plainlinks hlist navbar-mini"><ul><li class="nv-view"><a href="/wiki/Template:Types_of_programming_languages" title="Template:Types of programming languages"><abbr title="View this template">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:Types_of_programming_languages" title="Template talk:Types of programming languages"><abbr title="Discuss this template">t</abbr></a></li><li class="nv-edit"><a href="/wiki/Special:EditPage/Template:Types_of_programming_languages" title="Special:EditPage/Template:Types of programming languages"><abbr title="Edit this template">e</abbr></a></li></ul></div><div id="Types_of_programming_languages" style="font-size:114%;margin:0 4em"><a href="/wiki/Programming_paradigm" title="Programming paradigm">Types of programming languages</a></div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%">Level</th><td class="navbox-list-with-group navbox-list navbox-odd hlist" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/Machine_code" title="Machine code">Machine</a></li>
<li><a href="/wiki/Assembly_language" title="Assembly language">Assembly</a></li>
<li><a href="/wiki/Compiled_language" title="Compiled language">Compiled</a></li>
<li><a href="/wiki/Interpreted_language" class="mw-redirect" title="Interpreted language">Interpreted</a></li></ul>
<ul><li><a href="/wiki/Low-level_programming_language" title="Low-level programming language">Low-level</a></li>
<li><a href="/wiki/High-level_programming_language" title="High-level programming language">High-level</a></li>
<li><a href="/wiki/Very_high-level_programming_language" title="Very high-level programming language">Very high-level</a></li>
<li><a href="/wiki/Esoteric_programming_language" title="Esoteric programming language">Esoteric</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Programming_language_generations" title="Programming language generations">Generation</a></th><td class="navbox-list-with-group navbox-list navbox-even hlist" style="width:100%;padding:0"><div style="padding:0 0.25em">
<ul><li><a href="/wiki/First-generation_programming_language" title="First-generation programming language">First</a></li>
<li><a href="/wiki/Second-generation_programming_language" title="Second-generation programming language">Second</a></li>
<li><a href="/wiki/Third-generation_programming_language" title="Third-generation programming language">Third</a></li>
<li><a href="/wiki/Fourth-generation_programming_language" title="Fourth-generation programming language">Fourth</a></li>
<li><a href="/wiki/Fifth-generation_programming_language" title="Fifth-generation programming language">Fifth</a></li></ul>
</div></td></tr></tbody></table></div>
<div class="navbox-styles"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1129693374"><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r1236075235"><style data-mw-deduplicate="TemplateStyles:r1038841319">.mw-parser-output .tooltip-dotted{border-bottom:1px dotted;cursor:help}</style></div><div role="navigation" class="navbox authority-control" aria-label="Navbox" style="padding:3px"><table class="nowraplinks hlist navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Help:Authority_control" title="Help:Authority control">Authority control databases</a>: National <span class="mw-valign-text-top noprint" typeof="mw:File/Frameless"><a href="https://www.wikidata.org/wiki/Q275603#identifiers" title="Edit this at Wikidata"><img alt="Edit this at Wikidata" src="//upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" decoding="async" width="10" height="10" class="mw-file-element" srcset="//upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/15px-OOjs_UI_icon_edit-ltr-progressive.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/20px-OOjs_UI_icon_edit-ltr-progressive.svg.png 2x" data-file-width="20" data-file-height="20" /></a></span></th><td class="navbox-list-with-group navbox-list navbox-odd" style="width:100%;padding:0"><div style="padding:0 0.25em"><ul><li><span class="uid"><a rel="nofollow" class="external text" href="https://d-nb.info/gnd/4195096-3">Germany</a></span></li><li><span class="uid"><a rel="nofollow" class="external text" href="https://id.loc.gov/authorities/sh86003454">United States</a></span></li><li><span class="uid"><a rel="nofollow" class="external text" href="https://catalogue.bnf.fr/ark:/12148/cb12067891q">France</a></span></li><li><span class="uid"><a rel="nofollow" class="external text" href="https://data.bnf.fr/ark:/12148/cb12067891q">BnF data</a></span></li><li><span class="uid"><span class="rt-commentedText tooltip tooltip-dotted" title="logické programování"><a rel="nofollow" class="external text" href="https://aleph.nkp.cz/F/?func=find-c&amp;local_base=aut&amp;ccl_term=ica=ph122430&amp;CON_LNG=ENG">Czech Republic</a></span></span></li><li><span class="uid"><a rel="nofollow" class="external text" href="http://catalogo.bne.es/uhtbin/authoritybrowse.cgi?action=display&amp;authority_id=XX550687">Spain</a></span></li><li><span class="uid"><a rel="nofollow" class="external text" href="https://www.nli.org.il/en/authorities/987007553495005171">Israel</a></span></li></ul></div></td></tr></tbody></table></div>
<!-- 
NewPP limit report
Parsed by mw‐web.eqiad.main‐76ccb8c4bd‐6xb7k
Cached time: 20250105002236
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.890 seconds
Real time usage: 1.221 seconds
Preprocessor visited node count: 4416/1000000
Post‐expand include size: 163232/2097152 bytes
Template argument size: 1196/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 60/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 291824/5000000 bytes
Lua time usage: 0.530/10.000 seconds
Lua memory usage: 5454847/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1024.602      1 -total
 39.38%  403.496      1 Template:Reflist
 24.99%  256.058     30 Template:Cite_journal
  9.20%   94.295      1 Template:Short_description
  8.56%   87.733      4 Template:Navbox
  8.27%   84.763      1 Template:Programming_paradigms_navbox
  6.37%   65.305      2 Template:Pagetype
  6.10%   62.503      1 Template:Commons_category
  5.87%   60.100      1 Template:Sister_project
  5.68%   58.182      1 Template:Side_box
-->

<!-- Saved in parser cache with key enwiki:pcache:17927:|#|:idhash:canonical and timestamp 20250105002236 and revision id 1259279203. Rendering was triggered because: page-view
 -->
</div><!--esi <esi:include src="/esitest-fa8a495983347898/content" /> --><noscript><img src="https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?useformat=desktop&amp;type=1x1&amp;usesul3=0" alt="" width="1" height="1" style="border: none; position: absolute;"></noscript>
<div class="printfooter" data-nosnippet="">Retrieved from "<a dir="ltr" href="https://en.wikipedia.org/w/index.php?title=Logic_programming&amp;oldid=1259279203">https://en.wikipedia.org/w/index.php?title=Logic_programming&amp;oldid=1259279203</a>"</div></div>
					<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Help:Category" title="Help:Category">Categories</a>: <ul><li><a href="/wiki/Category:Logic_programming" title="Category:Logic programming">Logic programming</a></li><li><a href="/wiki/Category:Computer-related_introductions_in_1972" title="Category:Computer-related introductions in 1972">Computer-related introductions in 1972</a></li><li><a href="/wiki/Category:Programming_paradigms" title="Category:Programming paradigms">Programming paradigms</a></li><li><a href="/wiki/Category:Logic" title="Category:Logic">Logic</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul><li><a href="/wiki/Category:CS1_maint:_DOI_inactive_as_of_November_2024" title="Category:CS1 maint: DOI inactive as of November 2024">CS1 maint: DOI inactive as of November 2024</a></li><li><a href="/wiki/Category:Articles_with_short_description" title="Category:Articles with short description">Articles with short description</a></li><li><a href="/wiki/Category:Short_description_matches_Wikidata" title="Category:Short description matches Wikidata">Short description matches Wikidata</a></li><li><a href="/wiki/Category:CS1:_long_volume_value" title="Category:CS1: long volume value">CS1: long volume value</a></li><li><a href="/wiki/Category:Commons_category_link_from_Wikidata" title="Category:Commons category link from Wikidata">Commons category link from Wikidata</a></li><li><a href="/wiki/Category:Webarchive_template_wayback_links" title="Category:Webarchive template wayback links">Webarchive template wayback links</a></li></ul></div></div>
				</div>
			</main>
			
		</div>
		<div class="mw-footer-container">
			
<footer id="footer" class="mw-footer" >
	<ul id="footer-info">
	<li id="footer-info-lastmod"> This page was last edited on 24 November 2024, at 08:48<span class="anonymous-show">&#160;(UTC)</span>.</li>
	<li id="footer-info-copyright">Text is available under the <a href="/wiki/Wikipedia:Text_of_the_Creative_Commons_Attribution-ShareAlike_4.0_International_License" title="Wikipedia:Text of the Creative Commons Attribution-ShareAlike 4.0 International License">Creative Commons Attribution-ShareAlike 4.0 License</a>;
additional terms may apply. By using this site, you agree to the <a href="https://foundation.wikimedia.org/wiki/Special:MyLanguage/Policy:Terms_of_Use" class="extiw" title="foundation:Special:MyLanguage/Policy:Terms of Use">Terms of Use</a> and <a href="https://foundation.wikimedia.org/wiki/Special:MyLanguage/Policy:Privacy_policy" class="extiw" title="foundation:Special:MyLanguage/Policy:Privacy policy">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a rel="nofollow" class="external text" href="https://wikimediafoundation.org/">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>
</ul>

	<ul id="footer-places">
	<li id="footer-places-privacy"><a href="https://foundation.wikimedia.org/wiki/Special:MyLanguage/Policy:Privacy_policy">Privacy policy</a></li>
	<li id="footer-places-about"><a href="/wiki/Wikipedia:About">About Wikipedia</a></li>
	<li id="footer-places-disclaimers"><a href="/wiki/Wikipedia:General_disclaimer">Disclaimers</a></li>
	<li id="footer-places-contact"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
	<li id="footer-places-wm-codeofconduct"><a href="https://foundation.wikimedia.org/wiki/Special:MyLanguage/Policy:Universal_Code_of_Conduct">Code of Conduct</a></li>
	<li id="footer-places-developers"><a href="https://developer.wikimedia.org">Developers</a></li>
	<li id="footer-places-statslink"><a href="https://stats.wikimedia.org/#/en.wikipedia.org">Statistics</a></li>
	<li id="footer-places-cookiestatement"><a href="https://foundation.wikimedia.org/wiki/Special:MyLanguage/Policy:Cookie_statement">Cookie statement</a></li>
	<li id="footer-places-mobileview"><a href="//en.m.wikipedia.org/w/index.php?title=Logic_programming&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
</ul>

	<ul id="footer-icons" class="noprint">
	<li id="footer-copyrightico"><a href="https://wikimediafoundation.org/" class="cdx-button cdx-button--fake-button cdx-button--size-large cdx-button--fake-button--enabled"><img src="/static/images/footer/wikimedia-button.svg" width="84" height="29" alt="Wikimedia Foundation" loading="lazy"></a></li>
	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/" class="cdx-button cdx-button--fake-button cdx-button--size-large cdx-button--fake-button--enabled"><img src="/w/resources/assets/poweredby_mediawiki.svg" alt="Powered by MediaWiki" width="88" height="31" loading="lazy"></a></li>
</ul>

</footer>

		</div>
	</div> 
</div> 
<div class="vector-settings" id="p-dock-bottom">
	<ul></ul>
</div><script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgHostname":"mw-web.eqiad.main-76ccb8c4bd-9z678","wgBackendResponseTime":168,"wgPageParseReport":{"limitreport":{"cputime":"0.890","walltime":"1.221","ppvisitednodes":{"value":4416,"limit":1000000},"postexpandincludesize":{"value":163232,"limit":2097152},"templateargumentsize":{"value":1196,"limit":2097152},"expansiondepth":{"value":14,"limit":100},"expensivefunctioncount":{"value":60,"limit":500},"unstrip-depth":{"value":1,"limit":20},"unstrip-size":{"value":291824,"limit":5000000},"entityaccesscount":{"value":1,"limit":400},"timingprofile":["100.00% 1024.602      1 -total"," 39.38%  403.496      1 Template:Reflist"," 24.99%  256.058     30 Template:Cite_journal","  9.20%   94.295      1 Template:Short_description","  8.56%   87.733      4 Template:Navbox","  8.27%   84.763      1 Template:Programming_paradigms_navbox","  6.37%   65.305      2 Template:Pagetype","  6.10%   62.503      1 Template:Commons_category","  5.87%   60.100      1 Template:Sister_project","  5.68%   58.182      1 Template:Side_box"]},"scribunto":{"limitreport-timeusage":{"value":"0.530","limit":"10.000"},"limitreport-memusage":{"value":5454847,"limit":52428800}},"cachereport":{"origin":"mw-web.eqiad.main-76ccb8c4bd-6xb7k","timestamp":"20250105002236","ttl":2592000,"transientcontent":false}}});});</script>
<script type="application/ld+json">{"@context":"https:\/\/schema.org","@type":"Article","name":"Logic programming","url":"https:\/\/en.wikipedia.org\/wiki\/Logic_programming","sameAs":"http:\/\/www.wikidata.org\/entity\/Q275603","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q275603","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2001-07-26T10:05:49Z","dateModified":"2024-11-24T08:48:51Z","headline":"programming paradigm based on formal logic"}</script>
</body>
</html>